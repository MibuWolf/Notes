---
tags:
  - graphics opengl
---

# 1. 使用Shader

## 1.1 顶点着色器(VertexShader)

点着色器主要用于控制顶点的空间转换和顶点属性的计算，渲染管线会将顶点着色器输出的顶点位置传递给光栅化阶段进行光栅化处理。当然处理对顶点进行空间转换外还可以将一些在CPU中的计算移入顶点着色器(GPU计算)以获得性能提升。如：例子特效中的粒子运动，骨骼动画中的骨骼位置信息等。当然在引入高级Shader计算着色器后在计算着色器中处理也可能是更合适的旋转。如下图为最简单的顶点着色器代码：

![[计算机图形学/attachments/Pic_082.png]]

其功能非常简单就是将从主机(CPU)传入的顶点数据直接传入光栅化阶段。上图中标记了着色器的基本语法和用法。

## 1.2 片元着色器(FragmentShader)

片元着色器主要作用是以光栅化后的数据计算出每个像素的颜色值。以下为最简单的片元着色器，将每个像素设为固定的颜色值：

![[计算机图形学/attachments/Pic_083.png]]

## 1.3 加载编译使用Shader

Shader代码是以字符串形式传输到图形硬件的，因此必须对其进行编译连接并且将不同的Shader(顶点着色器,片元着色器)整合到一个着色器程序中，以便以一致的方式在整个渲染管线的不同步骤中配合处理。以下是OpenGL中创建编译使用着色器的API接口：

![[计算机图形学/attachments/Pic_084.png]]

在将所有所需类型(顶点，片元等)的所有着色器编译通过后则需要创建一个着色器程序，并将以上所有着色器链接到着色器程序上。

![[计算机图形学/attachments/Pic_085.png]]

至此着色器的创建加载编译链接到着色器程序等步骤都已完成，接下来就是在每帧绘制显示对象时根据显示对象材质启用该着色器即可，即：

![[计算机图形学/attachments/Pic_086.png]]

# 2. 顶点缓冲区对象与顶点数组对象

## 2.1 顶点缓冲区概述

顶点数据包含顶点属性(例如：颜色，法线，UV坐标等)通过顶点缓冲区存储在设备上(显存)。使用顶点缓冲区的常见流程是：先在设备(显存)上创建一个顶点缓冲区。 然后将主机(在CPU创建存储在内存)上的顶点数据列表拷贝到顶点缓冲区。具体代码如下：

![[计算机图形学/attachments/Pic_087.png]]

##  2.2 顶点数组对象

顶点缓冲区对象仅仅是顶点及属性存储的容器，也就是说它只是一块连续的显存地址并不知道存储其中的数据的结构，也就无法向Shader提供数据。而顶点数组对象的作用则是为OpenGL提供顶点的数据结构。回想下Shader中的输入数据：$layout (location = 0) in vec3 aPos; layout (location = 1) in vec3 aNormal;$ 顶点数组对象的作用就是让着色器程序可以从顶点缓冲区的对应位置获取数据。顶点数组对象的使用方式如下：

![[计算机图形学/attachments/Pic_088.png]]

# 3. OpenGL数学库及Shader参数传递

## 3.1 概述

OpenGL本身并没有强大的数学库，一般使用是常用GLM库作为数学库与OpenGL配合使用，当然你也可以自己封装数学库。GLM提供了图形学中常用的数学模型，如$glm::vec3; glm::vec4; glm:mat4$等甚至提供了常用的矩阵构成接口如构建视图矩阵的$glm:lookAt$构建投影矩阵的$glm::perspective$等。

## 3.2 在Shader中使用外部变量

我们在编写Shader代码时经常需要用到一些除顶点信息外的其他数据作为计算参数。此时我们需要使用uniform关键字来表示需要从主机(CPU)传到设备(GPU)Shader中的参数，最常见的如MVP矩阵信息。以下示例中将每帧改变像素颜色信息，假设着色器程序已按之前的内容初始化完成，从主机传递参数到着色器程序代码示例如下：

![[计算机图形学/attachments/Pic_089.png]]

# 4. 逐顶点/逐片元Shader

## 4.1 概述

我们已经介绍了顶点数据传输，也了解了如何给Shader传递参数，接下来我们就可以在顶点着色器中逐顶点进行计算并传递参数给片元着色器，之后顶点数据经过光栅化后被传入片元着色器开始逐像素计算。

## 4.2 Blinn-Phong光照

Blinn-Phong光照原理请参见3D数学基础，基于OpenGL的代码请参见[https://gitee.com/MibuWolf/FundamentaOfComputerGraphics.git](https://gitee.com/MibuWolf/FundamentaOfComputerGraphics.git)的Blinn-PhongLigth分支。

# 5. 模型对象

## 5.1 概述

之前的所有Shader演示都是在代码中自定义简单模型的顶点信息，实际在实现中真正的模型一般会以数据的形式存储在模型文件中，如：.obj, .fbx等。这些文件中存储的顶点信息的坐标轴不一定与我们使用的坐标轴一直，因此有些情况下可能需要校正模型坐标轴后再转换到世界空间。

## 5.2 实例化

由于一个模型文件中存储的是基础的模型顶点法线等信息，当我们需要在场景中绘制多个模型对象时，我们并不需要为每个实例单独开辟内存来存储顶点信息，相反我们通过运行时的数据，不同的材质，不同的参数可以将同一份的顶点数据绘制多个不同的实例，如下图中三条颜色不同的龙其实都是同一份模型信息。

![[计算机图形学/attachments/Pic_090.png]]

# 6. 纹理对象

## 6.1 纹理贴图的使用

使用纹理贴图的第一步是先将纹理从硬盘加载到内存中，然后将内存中的纹理贴图拷贝到显存，设置纹理贴图使用参数(如：采样方式，纹理模式等)，如下图：

![[计算机图形学/attachments/Pic_091.png]]

## 6.2 顶点数据中增加UV坐标

与贴图相互配合的就是UV坐标，添加的方法就是在顶点数据中增肌uv坐标的顶点属性。

## 6.3 每帧绘制时与Shader配合使用贴图采样

在主机端需要设置的是激活i号纹理，将i号纹理填充到Shader中的变量，将i号纹理与具体纹理对象句柄绑定。

![[计算机图形学/attachments/Pic_092.png]]

# 7. 总结

本章主要介绍的是一些OpenGL用法相关的内容可以参考：[https://gitee.com/MibuWolf/FundamentaOfComputerGraphics.git](https://gitee.com/MibuWolf/FundamentaOfComputerGraphics.git)各个分支的示例代码