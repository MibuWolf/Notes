
---
tags:
  - graphics texture
---

# 纹理贴图

纹理贴图一般用来表达物体表面的显示细节，这些细节包括表面颜色，阴影，光照信息设置与显示无关的数据等。既然纹理贴图中存储的是物体表面信息，读取这些信息的过程就是纹理采样。(此采样过程同样会遇到<<滤波器与图像信息处理>>中提到的走样问题)

# 纹理采样与纹理坐标方程

## 概述

为了读取物体表面纹理贴图的颜色值，我们需要一个从物体表面到纹理的映射函数，方便我们获取表面任意一点纹理贴图的像素值这个函数称为纹理坐标函数。仅仅通过物体表面上的纹理坐标映射到纹理贴图上的颜色值显然是不够的，如下图我们发现仅按纹理坐标取出像素值在某些情况下会有明显的锯齿(走样)：

![[计算机图形学/attachments/Pic_034.png]]

因此纹理坐标函数不仅仅要提供从纹理坐标到颜色值，还要尽量保证提供出来的像素么有太多的走样。

## 几种常见的纹理坐标

最常见的纹理坐标形式无非是2D和3DUV坐标。其他形式的纹理坐标如球形坐标，圆柱体坐标并不常见，此处仅介绍2DUV坐标和立方体坐标。2D贴图最为常见就是使用u坐标映射一张图的横向V坐标映射图片纵向获取此图像素信息。3D贴图就是所谓的立方体贴图，其基本原理是使用前后左右上下六张贴图组成的纹理集保存物体表面信息，通过坐标映射的方式确定使用哪张贴图中的哪个颜色值。立方体贴图采样过程大致如下：判定一个点坐标中绝对值最大的轴向作为选择立方体纹理面的依据，如: 某点 $|y| > |x| > |z|$则选取与y轴对应的立方体贴图中上下两个面根据y的正负选择上/下面为采样的纹理，在用$x,z$坐标在此张纹理贴图中采样。

## 纹理模式

对于纹理坐标范围超出$[0,1]$部分的处理，根据处理方式不同就形成几种不同的纹理模式：包装，镜像，钳夹等，于以下是各种模式的示意图：

![[Pic_035.gif]]

# 纹理抗锯齿

## 纹理走样

通过纹理坐标读取纹理颜色值得过程其实就是采样的过程，采样过程解决锯齿的方式是加大采样频率和使用过滤器。采样频率当纹理贴图固定后就无法改变(任何大小都映射到$uv$坐标的$[0,1]$)，能用的手段只有滤波器函数。

## 纹理空间足迹

滤波器函数中最重要的属性是范围，简单说也就是计算表面某uv坐标像素时滤波器需要计算的原始贴图中的像素范围(将这些像素使用某种滤波函数求平均数)。在纹理采样中我们将此滤波器范围定义为像素的纹理空间足迹。在纹理滤波器中这个问题比较复杂因为不同区域的纹理空间足迹(滤波器范围)可能不同，如下图：

![[计算机图形学/attachments/Pic_036.png]]

## 纹理重构到物体表面

上面介绍了采样时纹理空间足迹的不同，同样的采样完成后在物体表面重构图像是也会遇到走样的问题。将上图纹理与表面图像空间互换就是重构时走样的原因。此时仍然需要滤波器函数处理走样问题。对很多系统来说这些操作会成为明显的性能瓶颈。因此很多系统采用空间换时间的方式采用Mipmap的方式解决走样的问题。

## MipMap

MipMap的思想是将原始贴图生成为$n$个级别的mipmap贴图根据需要从不同等级贴图中采样，一般是以$uv$各两倍为一个级别(eg：$1024*1024$贴图为0级$512*512$为1级...直到1*1为第10级)使用MipMap的大致流程如下：

- **计算uv坐标表面面积：**由表面附近顶点坐标值和UV坐标值可以估算出该点附近uv坐标从$0~1$是表面面积大小。(如相邻两点坐标$(100,200,10), (110, 208,10)$UV分别为$(0.1,0.1) (0.2,0.2))$U方向$0.1$表示$10$，$V$方向$0,1$表示$8.$。 UV(从0-1)面积按大取为$100*100$。
- **根据面积计算使用MipMap级别并采样：**假设面积为D，则计算某$uv$坐标颜色值如下：

  ![[计算机图形学/attachments/Pic_037.png]]

- **各项异性采样：**以上方式对大多数情况使用效果都很好，但当对细长(如长度是100宽度为10)区域采样时会出现明显走样，这是因为mipmap是按照长边100计算面积的$(100*100)$，此时短边部分会被明显压缩。因此此时需要各向异性采样，具体做法是：取短边计算面积并选取mipmap级别，然后沿长边构成的mipmap级别平均。(如：短边计算级别8，长边计算级别6则在6-8级别之间采样求平均值)

# 纹理贴图的应用

## 控制着色参数

贴图的最基本用法就是为物体表面提供颜色信息，但并非只能存储漫反射颜色信息。贴图可以存储其他任何参数如：粗糙度，高光反射率，光泽度等。

## 法线及凹凸贴图

3D数学基础的<<凹凸贴图与切线空间>>详细的介绍了法线贴图，凹凸贴图的用法和效果。此外还有一种位移贴图DisplacementMaps其效果与法线贴图类似，但是其本质是改变原模型顶点位置。位移贴图中存储的是偏移距离，物体表面点会沿该点的法线方向移动该偏移距离。从而通过真实顶点的移动形成表面凹凸感。

## 阴影图

ShadowMap是一种用来处理阴影的方式，它的基本原理是在光源位置沿光线方向构建师徒和投影矩阵，然后绘制深度信息到阴影图。也就是说ShadowMap中存储的是当前光源可以射到的物体表面。当真正绘制物体时在与深度图中的深度比较，大于深度图中存储深度信息的部分在阴影中。

## 环境图

环境贴图又叫反射贴图是用来模拟周围环境对物体的影响。其原理是在物体位置分别向上下左右前后拍摄六张环境图像组成一个立方体贴图。当绘制物体时，由眼睛到物体表面的反射向量(以法线为中心的反射)射到立方体上的像素作为环境对此表面的影响值。

# 程序(过程)纹理

## 概述

之前介绍的所有纹理贴图都是将颜色值，反射率等信息存储在纹理中，而程序(过程)纹理是通过使用数学(算法)的计算生成而非直接存储数据的纹理。以下介绍几种简单的过程纹理。

## 3D条形纹理

此类纹理仅与位置有关，根据位置计算出当前位置的颜色值，有多种方法可以生成条形纹理，假设条形纹理两种颜色分别为c0和c1.最简单根据位置计算颜色的方法是：

![[计算机图形学/attachments/Pic_038.png]]

## 固体噪声/Perlin噪声

在图形学中经常会用到类似茶叶蛋上那种"斑驳"的纹理，Perlin噪声就是用来计算和创建此类效果的算法。 其基本方法如下(为了简单以二维坐标为例，三维算法是一样的)：
- **构建晶格(体)：**为求任意坐标$(x,y)$的噪声值，先构建晶格(三维坐标则是立方体)，四个顶点分别是$p0 = (int(x),int(y))$,        $p1 = (int(x)+1,int(y))$     $p2 = (int(x),int(y)+1)$     $p3 = (int(x)+1,int(y)+1)$坐标$(x,y)$在晶格内的相对坐标$p=(x-int(x), y-int(y))$,如下图：

   ![[计算机图形学/attachments/Pic_039.png]]
- 构建n个随机单位向量：构建n个随机方向的单位向量，如256个随机方向单位向量$G[256]$。
- 使用伪随机算法为晶格每个顶点随机选取梯度向量：利用伪随机算法为每个晶格(体)顶点选出一个随机单位向量。也可以利用如下算法确定随机单位向量$G[n]$中的索引：(x %n +y) % n  $（x,y）$坐标表示晶格四个顶点坐标(为四个顶点分别计算其随机方向向量)。
- 计算单个晶格顶点对该坐标的影响：遍历每个晶格(体)顶点，用点p到该顶点的向量与随机的梯度向量相乘再乘以平滑过度系数可以得出该顶点对坐标噪音的影响。即$Ni = (p-pi) Dot (G[i]) * F(p.x)*F(p.y)$。 平滑过滤函数为：当$|t|<1$时，   $F(t) = 2|t|³ - 3|t|²+1$  其余时候$F(t) = 0$
- 计算最终该点的Noise值：将所有晶格顶点的Noise值相加即为最终nosie值.

 ![[计算机图形学/attachments/Pic_040.png]]

***注：由以上算法的出的噪声图每个点的噪声可能为正也可能为负$[-1,1]$，有些时候会将噪声平滑过度到$[0,1]$范围如下图：***

![[计算机图形学/attachments/Pic_041.png]]
![[计算机图形学/attachments/Pic_042.png]]

# 总结

- 常用的贴图有2D贴图和3D贴图，对贴图采样时可能会出现失真，因此需要mipmap来减少失真
- 贴图除了存储表面颜色信息，还常用来存储法线环境光等信息，另外制作阴影时可可能用到ShadowMap
- 除了存储表面信息的纹理之外还有程序(过程)纹理，使用数学算法计算出纹理信息，如佩林噪声图。

