---
tags:
  - graphics opengl
---

# 1. 图形硬件

## 1.1 概述

图形硬件描述了使用专门基于光栅化的硬件架构，将3D对象快速渲染为计算机屏幕上的像素所必须的硬件组件。图形硬件(通常是指GPU)为用户提供了可编程的API接口。更多关于硬件管线请参考3D数学基础[[14. 实时图形渲染管线|实时图形渲染管线]]。

## 1.2 异构多处理

异构多处理的含义是：在使用图形硬件是，CPU，GPU是分布单独计算的，常用"主机host"来代指CPU包括其可使用的线程和内存。"设备device"代指GPU或图形处理单元及其相关线程和显存。两者相互独立各自单独运行，也正因此需要在两者之间传递数据和指令。

## 1.3 OpenGL

OpenGL是跨平台图形硬件API，我们将以OpenGL为例了解硬件编程的概念和基本示例。

# 2. OpenGL编程

## 2.1 概述

使用OpenGL编程时，必须同时编写CPU和GPU程序，GPU程序即各种Shader，CPU程序则是通过调用gl开头的API接口设置传递数据给GPU，两者配合使用从而构建出完整的渲染管线。

## 2.2 图形编程中的常用概念

缓冲区，(渲染)状态和着色器是图形学编程中常见的基本概念。缓存区是指设备(GPU)上的线性存储分配空间(显存空间)，可以存储GPU将使用的各种数据。(渲染)状态是 保存和记录了场景数据和着色器关联的计算将如何在图形硬件上进行的相关设置(如：设置混合模式等)。 着色器则表示顶点或者片元在GPU上计算的方式。

# 3. 缓冲区Buffer

## 3.1 缓冲区Buffer

缓冲区是设备(GPU)用来存储顶点，纹理等数据的存储器，是在显存中开辟的用于设备(GPU)读写的区域，因此在开始绘制前需要应用程序将几何信息贴图纹理等数据从主机(CPU)内存拷贝/填充到缓冲区。同样执行完绘制等操作后也可以从缓冲区拷贝回主机内存。

## 3.2 双缓存与周期性刷新

 为了解决渲染频率和显示频率不一致而导致的画面撕裂的问题，一般采用双缓存机制，即有两个同样大小的缓冲区一个用于后台绘制，另一个用于前台显示，当后台缓冲区完全绘制完成时会与前台缓冲区交换，此时已经绘制完成的后台缓存区提交到了前台，上一帧中的前台缓存区回到后台开始下一帧的绘制。开始会之前的第一个操作就是清理该缓冲区中上一帧的数据，在OpenGL中可以使用如下代码：
 
 ![[计算机图形学/attachments/Pic_078.png]]

glClearColor(r,g,b,a)用于指定清理后的缓存区颜色r,g,b,a。glClear(GL_COLOR_BUFFER_BIT);表示仅清理颜色缓冲区，注意此时深度缓冲区/模板缓存请数据并未清理。如果也需要清理深度缓冲区则需要明确指定要清理的缓冲区类型如下：

![[计算机图形学/attachments/Pic_079.png]]

# 4. (渲染)状态

**渲染状态设置**：在之前3D数学基础的渲染管线中我们有提到，管线中的一部分操作是完全可编程的(eg:顶点着色器，片元着色器)，还有一部分是可以通过API设置的(eg: 指定融合参数，开启深度测试模板测试等)。而一般通过API设置的渲染相关的操作方式计算方式等就是渲染状态。例如设置开启深度测试，设置深度测试函数可以通过以下接口设置：

![[计算机图形学/attachments/Pic_080.png]]

# 5. 基本的OpenGL应用程序

以下代码是基于GLFW库的OpengGL渲染循环代码。代码很简单不做赘述，更多关于OpenGL的只是参见：[https://learnopengl-cn.github.io/](https://learnopengl-cn.github.io/)

![[计算机图形学/attachments/Pic_081.png]]

# 6. 几何体(Geometry)

Geometry是一个抽象的几何体概念，一般用来存储该几何体(如：模型)基本信息如顶点，法线，UV坐标等。

# 7. Shader

Shader在渲染管线中是完全可编程部分(如果忘记了可以回顾下3D数学基础中的渲染管线章节)，其中最重要的有两种着色器，一种是将顶点等数据经过MVP转换到裁剪空间的VertexShader。另一种是在光栅化之后对每个像素颜色值进行计算的PixelShader。除此之外常见的着色器类型还有几何着色器，计算着色器。

# 8. 总结

- 本章主要介绍了图形硬件绘制中常见的基本概念，并引入OpenGL的概念，在后续的章节中将以OpenGL为例简单介绍整个渲染管线的编码过程。
- 本章中介绍的概念很简单在此不做赘述。