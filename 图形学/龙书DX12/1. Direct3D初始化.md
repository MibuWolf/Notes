---
tags:
  - graphics d3d12
---

# 1. 概述

## 1.1 Direct3D12概述

`Direct3D`是一种底层图形应用程序API，它与硬件驱动协作使得`Direct`的指令转化为`GPU`中可以执行的机器指令，也就是说不同厂商的`GPU`只要通过驱动程序对接支持当前的`Direct3D`版本，我们在开发时就无需再去考虑不同规格不同厂商的硬件设备层面的更底层细节。`Direct3D12`较上一个版本的主要改进在于：其性能优化方面在大大减少`CPU`开销的同时又改进了对多线程的支持。因此相较于`Direct3D11`的`API`设计`Direct3D12`的`API`更加偏于底层，也更为复杂。

`Direct3D`采用的仍然是组件对象模型(`ComponentObjectModel COM`)，我们在使用Direct3D接口时无需自己创建/销毁(`new/delete`)，而只需通过`Direct3D`提供的接口获取，使用完成后对资源进行释放(Release)即可。后续代码示例中会展示具体`Direct3D`的具体用法。

## 1.2 Direct3D12中的基本概念

在`Direct3D`中有些常用的基本概念在后续学习中会经常遇到：纹理格式， 交换链和页面翻转， 深度/模板缓冲，资源与描述符，多重采样，`DXGI`等。我们在此简单介绍基本概念和含义，在后续的学习中这些概念会被经常使用。

**纹理格式:** 纹理是一种由数据元素构成的矩阵，大多数情况下它被用来存储图像数据(此时每个元素数据存储的是像素颜色)，但也有很多时候其存储的是一些其他数据信息，如：发现贴图存储的是发现的向量信息。但并不是所有类型的数据元素都可以组成纹理，它只能存储`DXGI_FORMAT`枚举的特定格式数据。eg: `DXGI_FORMAT_R32G32B32_FLOAT`表示纹理的每个数据元素由3个32位浮点数分量组成；

`DXGI_FORMAT_R16G16B16A16_TYPELESS`表示数据元素由4个16位分量组成，但16位分量的数据类型待定(具体四个分量是int float 还是其他类型未定，只是预先分配显存，待纹理绑定到渲染流水线时再具体制定其数据类型)

**交换链与页面翻转:** 交换链(`SwapChain`)也就是通常所说的双缓冲，即：一个缓冲用于显示另一个缓冲用于将渲染数据写入，当数据写入完毕后提交后台缓冲区显示，并将前台缓冲区作为写入对象。实际上交换链(`SwapChain`)不仅支持双缓冲也支持更多的缓冲区，但一般而言两个缓冲区就足够了。

**深度缓冲/模板缓冲:** 深度缓冲/模板缓冲本质上仍然是纹理。深度缓冲是一个与后台缓冲区大小一致，像素一一对象，其记录的是每个像素的深度信息，用于辅助判定每个渲染对象的像素点是否需要重新绘制。模板缓冲则是用来实现一些特殊效果的辅助缓冲，一个程序并不一定必须要使用模板缓冲，但是一旦使用，则模板缓冲总是与深度缓冲所绑定的，也就是说在定义这个特殊纹理时就需要制定深度缓冲和模板缓冲的纹理格式，eg: `DXGI_FORMAT_D24_S8_UINT`表示使用24位作为深度缓冲区8位位模板缓冲区。实际上深度缓冲与模板缓冲共同使用一块纹理显存。

**资源与描述符(`Resource and Descriptors`):** 在渲染过程中`GPU`需要对资源进行读写(eg: 读取纹理数据经过计算后写入GBuffer)，每次的绘制(`DrawCall`)都需要将相关资源进行绑定/链接到流水线上。但`GPU`并非将这些资源直接与渲染流水线绑定，而是通过一种名为描述符(`Descriptors`)的对象进行间接引用，描述符可以看作是送往`GPU`的资源描述的轻量级结构。描述符本质上就是一个中间层数据结构，通过描述符`GPU`不仅能知道资源数据，也能了解到该资源数据的更多详细信息。之所以需要描述符信息是因为在渲染过程中经常会出现同一份资源在不同渲染阶段的用途是不同的，例如：同一张纹理可能先被用来作为写入的RT对象，之后又被用来作为下一个渲染`Pass`的输入贴图。因此仅靠资源本身无法明确该资源的用途格式等内容。每个描述符都有其具体的类型，每种描述符类型表示该资源特定的作用（eg: `CBV`表示常量缓冲区视图/描述符，`Sampler`为为纹理贴图采样器，`RTV`为`render target view`，`DSV`为`depth;stencil View`等）。前面提到一个资源可能用于渲染流水线的不同阶段，此时就需要多个描述符表述该资源在不同阶段的信息，此时可以用描述符堆(`descriptor heap`)来表示。描述符堆中存有一系列描述符(可以将其看作描述符的数组)。

**注：很多时候视图(View)与描述符(Descriptors)是同一个意思，视图是早期Direct3D的术语，但在Direct3D12的某些API中仍然使用，例如：常量缓冲区视图(constant buffer view)与常量缓冲区描述符(从constant buffer descriptors)是同一个意思。**

**多重采样(Multosampling):** 多重采样的目的一般是用来解决锯齿/走样的问题，常见的多重采样的方案有`SSAA`(超级采样抗锯齿)和`MSAA`(多重采样抗锯齿)。超级采样抗锯齿(`SSAA`)的原理是：使用4倍与屏幕分辨率的大小作为后台缓冲区大小，渲染时先以4倍与屏幕分辨率的精度对场景进行绘制，然后使用降采样的方式还原到屏幕分辨率大小从而避免走样。此方案较为直接但其开销将会是正常渲染的4倍。多重采样抗锯齿(`MSAA`)的原理则是：只对一个像素进行着色计算，利用子像素/片元共享的一些计算信息将颜色信息分享给各个子像素/片元。例如使用4X多重采样时，实际参与着色计算的仍然是屏幕分辨率大小的像素点个数(无需像`SSAA`那样真的以4倍的数量计算，这也就是`MSAA`高效的原因)，对每个像素绘制完成后，再基于可见性和覆盖性(每个子像素/片元经过深度/模板测试)将该像素颜色值分享个每个子像素/片元。最终使用4个子像素/片元颜色值进行降采样完成抗锯齿效果。

**DXGI(DirectX图形基础结构 DirectX Graphics Infrastructure):** `DXGI`的基本理念是对多种图形`API`(`Direct2D Direct3D`)中所共有的底层任务进行封装使用一套API进行处理。因此经常会出现`Direct3D`与`DXGI`配合使用的情况。例如：2D和3D渲染中都要用到的交换链接口(`IDXGISwapChain`)，纹理格式枚举`DXGI_FORMAT`，对于硬件设备的检测查询相关接口等。

# 2. CPU与GPU交互

在进行图形编程时，我们一定要了解有两种处理器在参与工作:`CPU`与`GPU`，两者并行工作同时也需要同步。为了获得最佳性能，我们应该尽量让两者同时工作减少同步，因为同步就意味着有一种处理器要以空闲状态等待另一处理器完成某些任务。本节我们就来了解下`Direct3D12`中`CPU`与`GPU`是如何协作配合完成对3D场景的绘制的。

## 2.1 命令队列与命令列表(Command Queue / Command List)

每个GPU都至少维护着一个命令队列(`CommandQueue`)，`GPU`从名列队列中获取指令并开始执行，如果命令队列中没有指令则GPU处于空闲等待。而通过`Driect3D`的AI接口，`CPU`可以利用命令列表(`CommandList`)将指令提交到命令队列(`CommandQueue`)中去，从而实现CPU/GPU的交互同步。当然通过`CommandList`提交到`CommandQueue`中的指令并不一定会被立即执行，因为`GPU`总是按照`CommandQueue`中的指令顺序执行，如下图所示：

![[图形学/龙书DX12/attachments/Pic_001.png]]

在`Driect3D12`中`CommandQueue`被抽象为`ID3D12CommandQueue`接口来表示，通过接口`CreateCommandQueue`来创建。`CommandList`被抽象为`ID3D12GraphicsCommandList`接口，该接口提供了设置视口`RSSetViewPorts`，清理目标`RT ClearRenderTargetView`，调用`DrawCall`绘制 `DrawIndexedInstanced`等一系列的命令接口。当`CPU`层通过调用绘制接口完成一帧的所有绘制后续调用`ID3D12GraphicsCommandList::Close()`指令完成当前的指令记录，并通过`ID3D12CommandQueue::ExecuteCommandLists`接口将当前的`CommandList`提交到`CommandQueue`中。

实际上`ID3D12GraphicsCommandList`接口仅仅是为了收集指令方便而提供的接口，真正存储指令信息的是指令/命令分配器(`CommandAllocator`)，在调用`ID3D12CommandQueue::ExecuteCommandLists`接口时，命令队列(`CommandQueue`)就会引用命令分配器中记录的命令。在此先对其基本概念有个初步认识，具体用法细节会在后续陆续涉及。

## 2.2 CPU与GPU间的同步

由于`CPU`与`GPU`配合并行工作，自然也就存在同步问题。试想有一个资源`R`，如果`CPU`先将其属性(例如位置属性)设置为`p1`然后将该资源`R`与命令列表中的命令`C`绑定并以提交到命令队列等待`GPU`执行，此时`CPU`逻辑发生改变修改了资源`R`的属性改为了`p2`，此时就可能由于`CPU`与`GPU`的同步出现问题。如下图所示：

![[图形学/龙书DX12/attachments/Pic_002.png]]

一种简单的方式就是：强制`CPU`等待直到`GPU`完成一帧内所有指令后才进行执行。这种方法称为刷新命令队列，可以通过围栏(`ID3D12Fence`接口来实现)。其逻辑简单来说就是在`CPU`提交命令列表时增加当前围栏值，并挂起等待知道`GPU`执行为新的围栏值的所有指令后`CPU`才继续执行下一帧运算。如下图所示：

![[图形学/龙书DX12/attachments/Pic_003.png]]

## 2.3 资源转换与多线程

所谓的资源转换是指前面提到过的一个资源在渲染流水线的不同阶段用作不同用途，例如一个纹理可能先需要一个指令对其写入数据之后另一个操作将其作为输入贴图读取数据，如果在写入完成前就进行了读取可能会得到错误的数据。资源转换就是用来解决这样的问题的，`Direct3D`通过资源转换(转换资源屏障`Transition Resource Barrier`)显示的对同一资源的用途进行转化，这样就能保证在前面用途使用完成前(如写入操作)，后续新的资源用途指令不会进行。

此外`Direct3D12`还支持多线程，本系列笔记中并不涉及，可以在`Direct3D SDKde Multihreading12`示例中学习如何使用多线程并行生产命令列表。

# 3. 初始化Direct3D

在了解了`Direct3D12`中的常用概念后，我们在本节将介绍如何初始化`Direct3D`，本节会变书写代码边记录学习因此会涉及到大量代码及注释。项目工程地址在：https://github.com/MibuWolf/LearnDX12

对于`Direct3D`的初始化过程可以分为一些几个步骤，我们将按照步骤书写并搭建学习`DX12`的示例工程，初始化的具体步骤如下：

- 用`D3D12CreateDevice`接口创建`ID3D12Device`接口实例。
- 检查当前`D3DDevice`设备的基本信息
- 创建命令队列，命令列表分配其和命令列表
- 描述并创建交换链
- 创建应用程序所需的描述符堆
- 创建并绑定后台缓冲区及深度/模板缓冲区
- 设置是视口及裁剪矩阵

## 3.1 创建D3DDevice实例

创建`D3DDevice`实例的主要使用的是`D3D12CreateDevice`接口，关于该接口参数的含义及用法如下图所示：

![[图形学/龙书DX12/attachments/Pic_004.png]]

## 3.2 检查当前D3DDevice设备的基本信息

一旦`D3DDevice`设备创建完成，则需要检测当前设备的基础信息，根据不同`GPU`平台及硬件设备，我们或许会使用到的描述符大小可能各不相同，对`4XMASS`的支持也可能不同。因此在正式勇士该设备前我们需要查询并记录这些信息，此外还需为`CPU/GPU`同步创建好护栏(`Fence`)支持(当然也可以有其他方式做好`CPU/GPU`同步，此处仅以`Fence`方式为例)

![[图形学/龙书DX12/attachments/Pic_005.png]]

