---
tags:
  - cplusplus memorymodel atomicoperations
---

C++11标准中增加的最重要的特性之一就是新的多线程感知内存模型。大多数程序员可能都不会注意到它，这是因为该特性过于底层。一般情况下利用前面几章我们讨论了利用互斥元共享数据以及在线程之间通过事件 future等方式就足以实现线程间的并发与同步，至于他们为何如此工作或者说他们工作的细节就显得不是特别重要了。但随着你开发的深入，当你开发到越底层(越接近机器)时，内存模型的精确细节才会显得越来越重要。本章将从C++11的内存模型出发讨论其概念及原子类型和原子操作并进一步讨论如何使用它们提供多线程间的同步。

# 1. 内存模型基础

内存模型其实主要包含量两方面的内容：基本结构和并发。我们将分别从这两个方面进行讨论。

## 1.1 内存基本结构------对象与内存位置

在C++标准中将任意类型的对象定义为“存储区域”，无论什么类型的对象都会被存储在一个或多个内存位置中。每个这样的内存位置要么是一个标量类型的对象，eg: `int short MyClass*`。要么是相邻位域(位域就是制定当前变量占多少个字节eg: `int a:8`；)的序列。如下图所示，展示一个结构体如何划分为对象和内存位置：

![[C++/C++并发编程实战/attachments/Pic_048.png]]

## 1.2 对象 内存位置以及并发

这里是对于C++中多线程应用程序至关重要的部分，所有东西都取决于这些内存位置。如果两个 线程访问不同的内存位置，是没有问题的，一切工作正常。另一方面，如果两个线程访问相同的内存位置，并可能对其进行修改这就存在竞争条件(前面章节中有讨论)。

为了避免竞争条件，就必须确保其有一个确定的执行顺序，例如：前面章节所提到的互斥元或者后续讨论的原子操作。

## 1.3 多线程内存模型补充说明

本文中对内存模型的讨论过于简单，容易让人不知所谓，因此我在此做了更加详细的补充说明。在C++11标准中，一个重大的更新就是引入了C++多线程内存模型。这里讲的内存模型，并非讨论变量或者类在内存中的分布情况，或者内存分为堆 栈 代码区 等等。这里所讨论的内存模型指的是多线程编程中对共享内存的访问顺序(或者说内存模型的本质是指在单线程情况下CPU指令在多大程度上发生指令重排)。因此本章讨论的内存模型(`memory model`)更确切的说应该是"内存顺序模型"(`memory order model`)。

### 1.3.1 问题起源

早期的CPU，CPU之间能共享访问的只有内存，此时的结构大体如图：

![[C++/C++并发编程实战/attachments/Pic_049.png]]

随着硬件技术的发展，内存的访问已经跟不上CPU的执行速度，此时内存反而变成了瓶颈。为了加速读写速度，每个CPU也都有自己内部才能访问的缓存，结构变成了这样：

![[C++/C++并发编程实战/attachments/Pic_050.png]]

为了提升性能现代CPU已经变为上图中的架构：有多个CPU处理器，每个CPU处理器内部又有多个核心。存在只能被一个CPU核心访问的L1 cache。存在只能被一个CPU处理器的多个核心访问的L2 cache。存在能被所有CPU处理器都能访问到的L3 cache以及内存。

新的CPU架构在多线程中访问共享内存时就会产生各种各样的问题。例如：因为每个线程运行在不同的CPU核心，访问的cache缓存也各不相同，因此不同线程对内存数据的访问就可能存在问题，此外由于编辑对代码指令的优化就可能加剧这一问题。而本节的主角：内存模式(memory model)就是规定了各种不同的访问共享内存的方式，不同的内存模型，既需要编译器的支持，也需要硬件CPU的支持。

### 1.3.2 问题分析

至此你可能只有一个大致的概念甚至仍然完全不能了解：为什么现代CPU架构下多线程访问内存会出现问题，具体存在什么样的问题？别急，我们先看一个简单的例子：

|   |   |
|---|---|
|线程1|线程2|
|1. A = 1|3. B = 2|
|2. print(B);|4. print(A);|

假设A B两个变量的初始值都为0，在不使用任何锁和其他同步措施的前提下，两个线程将会交织执行，其执行结果有以下几种可能性：

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
||可能1|可能2|可能3|可能4|可能5|可能6|
|执行顺序|1,2,3,4|1,3,2,4|1,3,4,2|3,4,1,2|3,1,2,4|3,1,4,2|
|结果|A=1, B=0|A=1,B=2|A=1 ,B=2|A=0,B=2|A=1,B=2|A=1,B=2|

但是无论如何其执行结果都不会出现：A = 0， B = 0 的情况。为什么执行这段代码时不会出现结果为: A = 0， B = 0 呢？ 本质上的原因是执行顺序不可能是先执行：2，4或者 4, 2再执行其他操作。那么编辑器优化代码以及CPU执行指令时是如何保证不会出现这种执行顺序的呢？这就是顺序一致性模型在起作用，顺序一致性模型(Sequential Consistency)是我们要讨论的内存模型中最基础的内存模型，其定义为：

“… the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.”

这句话看起来很拗口，它对程序的执行结果有两个要求：

- 从单个线程的角度来看，每个线程内部的指令都是按照程序规定的顺序(program order)来执行的;(每个处理器的执行顺序和代码中的顺序（program order）一样。)
    
- 从整个多线程程序的角度来看，整个多线程程序的执行顺序是按照某种交错顺序来执行的，且是全局一致的;（所有处理器都只能看到一个单一的操作执行顺序。）
    

当然，顺序一致性代价太大，不利于程序的优化，现在的编译器在编译程序时通常将指令重新排序（当然前提是保证程序的执行结果是正确的），例如，如果两个变量读写互不相关，编译器有可能将读操作提前（暂且称为预读prefetch 吧），或者尽可能延迟写操作。例如下面的代码段：

![[C++/C++并发编程实战/attachments/Pic_051.png]]

上面的例子可以看出，编译器在不同的优化级别下确实对指令进行了不同程度重排，在 -O0(不作优化)的情况下，汇编指令和 C 源代码的逻辑相同，但是在 -O2 优化级别下，汇编指令和原始代码的执行逻辑不同，由汇编代码可以观察出，b = 22 首先执行，最后才是 a = b + 2， 由此看出，编译器会根据不同的优化等级来适当地对指令进行重排。在单线程条件下上述指令重排不会对执行结果带来任何影响。但是在多线程环境下就不一定了，如果另外一个线程依赖 a，b的值来选择它的执行逻辑，那么上述重排将会产生严重问题。

那么为什么编译器会做这样的乱序优化呢？因为读一个在内存中而不是在cache中的共享变量需要较长的时钟周期，所以编译器就“自作聪明”的让读操作先执行，从而隐藏掉一些指令执行的延迟，从而提高程序的性能。实际上，这种优化是串行时代非常普遍的，因为它对单线程程序的语义是没有影响的。但是在进入多核时代后，编译器缺少语言级的内存模型的约束，导致其可能做出违反顺序一致性规定的多线程语义的错误优化。同样的，多核CPU中的写缓冲区（store buffer）也可能实施乱序优化：它会把要写入内存的值先在缓冲区中缓存起来，以便让该写操作之后的指令先执行，进而出现违反顺序一致性的执行顺序。

因此，CPU 的乱序执行也需要作出适当的约束。综上所述，我们必须对编译器和 CPU 作出一定的约束才能合理正确地优化你的程序，那么这个约束是什么呢？答曰：内存模型。

### 1.3.3 C++多线程内存模型

为了更容易的进行多线程编程，程序员希望程序能按照顺序一致性模型执行；但是顺序一致性对性能的损失太大了，CPU和编译器为了提高性能就必须要做优化。对C++程序员来说，随着C++11标准的到来，我们终于可以依赖高级语言内建的多线程内存模型来编写正确的、高性能的多线程程序。

下面我们介绍几个常见的多线程内存模型：

#### 顺序一致性模型(SC)

当使用顺序一致性模型进行共享数据读写时如下图所示：

![[C++/C++并发编程实战/attachments/Pic_052.png]]

如上图所示在之前例子中两个线程都会对A B共享数据进行操作，为了保证顺序一致性就不得不有一个类似开关的机制保证顺序正确执行：当线程1将数据写入缓存1时，判定当前顺序是否正确，如果正确则将数据写回内存，然后继续执行下一步CPU操作指令，另一线程也是如此。这也就形成了瓶颈，为了保证顺序一致性正确，实际上同一时间还是只有一个线程在新进行读写操作。

#### 全存储排序(Total Store Ordering)模型

前面提到的顺序一致性模型读写内存为了保证顺序正确每次写操作都写入内存后才执行下一步骤，因此在性能上就会比较弱。而全存储排序模型下一个写操作只要写入本核心对应的写缓冲后就可以返回，执行效果明显较高(无需等待写入内存)，其基本结构如下图所示：

![[C++/C++并发编程实战/attachments/Pic_053.png]]

如上图所示在此模式下，每个线程将数据写入本地缓冲后即刻下一指令，这样就无法保证写入内存的数据与指令执行保持一致，此时就可能出现A B的输出值都为0的情况，如上图所示。其执行顺序就可能如下： 线程1 将B=1写入本地缓冲。 线程1输出A的值(从内存读取到本地缓冲此时内存中值为0)。线程2 将A=2写入本地缓冲。线程2输出B的值(从内存读取到本地缓冲此时内存中值为0)。线程1将写缓冲写回内存，线程2将写缓冲写回内存。

可以看到，在引入了只能由每个core才能访问到的写缓冲区之后，之前SC(顺序一致性模型)中不可能出现的输出(0,0)的情况在这样的条件下可能出现了。

