---
tags:
  - cplusplus locks
---

前面几章介绍了并发操作与原子类型，本章我们将来讨论在多线程之间并行操作的更为复杂的数据结构。原子类型是很好用的一种在多线程之间同步的数据类型，但在实际应用中我们所需要使用的数据更多时候会以自定义数据结构的方式来呈现。而这也正是本章所要讨论的内容------如何设计出基于锁的并发数据结构。

# 1. 为并发设计数据结构的含义

在最基本的层面，为并发设计数据结构意味着多个线程可以同时使用此数据结构，对此数据执行各种的操作，并且每个线程都有数据结构的一致性视图。不会丢失或破坏数据，维持所有不变量，并且没有不确定的竞争条件，此种数据结构就被称为线程安全的数据结构。

你可能很自然的就会想到：只要保证任意线程对此数据结构进行操作时都使用互斥元锁定就可以避免并发时数据竞争的问题。确实这样做可以避免数据竞争的问题，但是本质上此时多个线程对该数据结构的访问就退化成了线性操作读取数据(每个线程按锁定顺序线性操作整个数据结构)，这并非真正的并发操作。而我们的目标则是设计出可以真正支持并发访问的数据结构，因此在为并发存取设计数据结构时，我们需要考虑两个方面：**保证存取是安全**的以及**允许真正的并发存取**。

[[2. 在线程间共享数据|在线程间共享数据]]一章中我们已经讨论过一些如何**使得数据结构线程安全的基本原理。**例如：保证当数据结构不变性被别的线程破坏时的状态不被任何别的线程看到；注意避免数据结构接口所固有的竞争现象，通过为完整操作提供函数，而不是提供操作步骤；当使用数据结构时，通过限制锁的范围和避免使用嵌套锁，来降低产生死锁的机会等等，在此不做赘述。

至于**允许真正的并发存取**实际上并没有一个详尽的准则，而是当我们在设计数据结构时，有一系列问题需要我们自己思考和抉择：

- 锁的范围能否被限定，使得一个操作的一部分可以在锁外被执行？
- 数据结构的不同部分能否被不同的互斥元保护？
- 是否所有操作需要同样级别的保护？
- 数据结构的一个小改变能否在不影响操作语义情况下提高并发性的机会？

**所有这些问题的核心在于：如何将锁的颗粒化做到最小(将必然发生的序列化(线性操作)最小化)，并且能够最大限度的实现并发性。**

这也就是本章追寻的目标和为并发设计数据结构的意义。

# 2. 基于锁的并发数据结构

在理解了并发数据结构的含义之后我们来分析如何设计合理的并发数据结构。设计并发数据结构的困难点在于：1. 如果只用一个互斥元保护整个数据结构，我们需要确保此数据在互斥元保护之外不会被获取到(不会出现绕过互斥元对该数据结构进行读写)，并且不会发生接口所固有的竞争现象(参见[[2. 在线程间共享数据|在线程间共享数据]])，而且即使规避了这些问题，最终结果对此数据结构的实际操作也是线性的并非正在的并发。2. 如果使用独立的互斥元保护数据结构的独立部分，问题会变得更加复杂，例如：在多个互斥元之间可能存在死锁。因此，设计有多个互斥元的数据结构时，需要比设计只有一个 互斥元的数据结构考虑得更细致。本章我们将逐步分析和讨论如何在确保数据结构线程安全的前提下最大可能的拥有更大的并发性。

## 2.1 使用锁和条件变量保证数据结构线程安全

我们先回顾下之前章节中一个线程安全的栈的数据结构设计代码：

![[C++/C++并发编程实战/attachments/Pic_054.png]]

该线程安全的栈结构的设计是符合线程安全的，更多具体细节的内容可以回顾：[[2. 在线程间共享数据|在线程间共享数据]] 中的内容。但这样的数据结构设计仅仅是**保证存取是安全**但不满足**允许真正的并发存取。**这种实现方式本质上就是将多线程对栈的调用利用互斥元锁定形成了一个序列调用执行的模式。当在stack上存在显著竞争时(多个线程同时操作它时)，则会出现明显的性能限制，因为互斥元会让其无法并发方法而必须一个个顺序执行。

**注：当前这种写法的一个文档在于如果一个线程调用pop()函数，而恰好此时data中没有数据，那么该线程会一直尝试调用data.empty()并一直抛出异常。**

[[3. 在线程间同步并发操作|在线程间同步并发操作]]中关于线程安全队列的封装则解决了上述问题：

![[C++/C++并发编程实战/attachments/Pic_055.png]]

在该示例中， ❹处使用`condition wait`操作代替了抛出异常，可以避免调用`pop()`函数的线程在队列为空时频繁检查以及频繁抛出异常的问题。虽然解决了这个问题但是该方案仍然不是完美的，我们试想一下如果有多个线程都在`wait_and_pop()`，当一个数据被push到列表中后会触发`notify_one()`事件。如果接受该通知的线程在执行后续操作时发生了异常(如：❹后面的`std::shared_ptr<T>`构造时发成异常)，则后续不会有任何线程被唤醒。解决这一问题有三种方式：

1. 使用`notify_all()`代替`notify_one()`。这样固然可以通知到所有线程，但实际上每次只有一个线程能够读取数据，其他线程会因为被第一个线程读取完数据队列又变成空队列而再次进入`wait`状态(多数线程会被白白唤醒一次)。 

2. 则是在❹后面的可能发生异常的地方捕获异常，一旦发生异常再次抛出`notify_one()`事件给其他线程继续执行。

3. 则是将`std::shared_ptr<T>`的初始化前移到`push()`函数中，并存储`std::shared_ptr<T>`实列而非原始对象，这样就可以避免因构造时产生异常(线程间对象拷贝并不会引发异常)。如下图所示：

![[C++/C++并发编程实战/attachments/Pic_056.png]]

如上图所示将`shared_ptr<T>`的构造放在push()函数中不仅避免了在线程执行时构造`shared_ptr<T>`可能的异常错误，它还带来了一个额外的好处就是减少了互斥元锁定时间。我们知道内存分配是个开销昂贵的操作，在`Push()`中分配好内存避免在线程`lock`时执行内存分配操作，可以有效减少互斥元锁定时间。

上面的几个例子都是用一个互斥元保护整个数据结构，虽然通过几个示例的不断完善可以达到保证读取安全，但其本质上用一个互斥元保护整个数据结构的做法限制了数据结构的并发，任一时刻最多只会有一个线程来操作这些数据结构。而实际上通过控制数据结构的详细实现，可以提供更细粒度 的锁定，并且实现更高级别的并发。

## 2.2 使用细颗粒度锁和条件变量支持并发的线程安全

前面示例中的实现方式都是一个被保护的数据项(`queue/stack`)被一个互斥元保护，要实现数据结构访问的并发，我们需要使用细颗粒度锁与数据结构的不同数据项联系起来。首先我们来看一个单链表队列的实现示例，单链表队列数据结构如下图所示，头尾指针分别指向队列首尾，队列中每个节点指向下一/上一节点。

![[C++/C++并发编程实战/attachments/Pic_057.png]]

那么该数据结构的一个简单的单线程队列实现可以如下图所示：

![[C++/C++并发编程实战/attachments/Pic_058.png]]

在该代码示例中使用`std::unique_ptr<node>`来管理节点为的是当这些节点不再需要时可以直接移除而无需手动调用delete。tail为裸指针主要是因为它仅仅是个占位功能使用。

这样的封装方式在单线程下毫无问题，但当我们试图用细颗粒度锁将其扩展至多线程时就会出现问题。使用细颗粒度锁对其改进是一个自然的想法就是用两个互斥元分别保护队列的`head`和`tail`。但这样是存在问题的，例如 `push()`方法中执行到❹时需要对tail进行锁定，而`pop()`操作执行到❸时需要对head进行锁定。当队列中仅剩一个数据节点时，由于`head`和`tail`分别在不同线程中用不同的互斥元进行锁定，但实际上操作的又是同一内存因此会出现数据竞争的问题。

但这一问题并非不能解决的，我们来看一种通过分离数据允许并发的解决方案。

### 2.2.1 通过分离数据允许并发的

前面提到分别对`head`和`tail`使用独立互斥元锁定的问题在于当`head`和`tail`指向同一地址时，两个互斥元分别锁定就会使得这一地址的访问存在竞争。分离数据的基本思路是在链表增加一个不存储数据的傀儡节点，当链表为空时`head`和`tail`才会同时指向该傀儡节点，这样就可以有效的避免`head`和`tail`指向同一内存而导致的数据竞争问题，具体代码如下图所示：

![[C++/C++并发编程实战/attachments/Pic_059.png]]

如上图所示，经过这样的调整和修改后当链表中没有数据时`head`和`tail`指向同一个节点，在`push()`操作中只会访问和修改tail，而在`pop()`操作时仅在❸处短暂的同时读取`head`和`tail`。更为重要的是此时可以放心的为`head`和`tail`设置各自的互斥元锁，因为此时`head`和`tail`已经此时已经不会出现`head`和`tail`对同一内存操作的情况。

既然此时已经可以分别对`head`和`tail`使用不同互斥元锁定，那么接下来我们需要考虑的问题则是应该如何分别对`head`和`tail`进行锁定。我们的目标是最大程度的并发，因此在设计对`head`和`tail`锁定时希望持有锁的时间尽量短，这样才能更有效的实现并发。`push()`操作较为简单，它仅会操作`tail`而只要我们在内存分配之后对其锁定即可(内存分配会有较大开销，应尽量降低单个线程锁定的时间)，因此在❽和❾之间对`tail`锁定较为适合。同样在`pop()`时也遵循此原则对每个互斥元尽量降低其锁定时间，因此使用细颗粒度锁的线程安全队列实现如下图所示：

![[C++/C++并发编程实战/attachments/Pic_060.png]]

在此以更加严格的眼光重新审视下上述代码段。在`push()`方法中将内存分配和构造放置在互斥元锁定之前，不仅可以减少和降低互斥元锁定时间(内存分配需要较大开销)，而且还保证了此处的锁定是异常安全的，因为即使在内存分配或者`std::shared_ptr`构造时发生异常也不会影响互斥元的锁定，更不会对其他线程产生影响。在`pop_head()`中先对`head`进行锁定再对`tail`进行锁定也有效的避免了逻辑错误和死锁的问题，假设在`pop_head()`中我们先对`tail`锁定取值再对`head`进行锁定，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_061.png]]

当A线程在❶处对`tail`锁定后，可能由于其他线程B已经调用了`pop_head()`方法，此时的`head_lock`已经被B线程锁定，因此A线程就不得不等待。考虑下复杂情况，假设此时B线程锁定了`head`，而C线程又在A线程之前调用了`pop_head()`接口(也就是说B线程解锁`head`后C线程继续锁定`head`然后才到A线程)。A线程就不得不进行长时间的等待，如果在等待过程中又有其他线程进行了`push()`操作，那么等到A线程获取到`head`锁定时，可能此时的临时变量`old_tail`早已不是队列中的有效数据因此会发生逻辑上的错误甚至崩溃。

实际上示例6.6中的实现方式中的锁是以很细的颗粒度进行锁定(极尽可能的减少锁定时间)，这样就为多线程的并发访问提供了更大更多时间上的可能性。

### 2.2.2 WaitAndPop

上述示例6.6中实现了`push()`和`try_pop()`的接口，但并未像示例6.2中那样实现`wait_and_pop()`函数。那么能否使用细颗粒度锁实现类似功能呢？答案是肯定的，但实现起来需要考虑的细节较多，先来看较为简单的`push()`函数，在此函数中只要有数据压入则通过`data_cond.notify_one()`通知其他线程。此处需要注意的是`data_cond.notify_one()`通知应该在对`tail`互斥元解锁之后发出，因为其他线程`wait_and_pop()`时需要获取`tail`进行安全性比较。在`wait_and_pop()`接口中则更为复杂，我的得思考在哪里`wait`，用哪个互斥元解锁等问题，一种不错的实现如下图所示：

![[C++/C++并发编程实战/attachments/Pic_062.png]]

上图中定义了基本的接口，此外可以清晰的看到，在6.8中`push()`接口是先解锁互斥元`tail_mutex`，然后在发出通知`data_cond_notify_one()`给其他线程的。(为的是避免其他`wait`线程的后续操作中使用`tail_mutex`互斥元)

![[C++/C++并发编程实战/attachments/Pic_063.png]]

如上图示例6.9所示❹❺是`wait_and_pop()`的两种重载接口。❶只是将队列中的头部节点弹出返回(其余线程安全及锁定等问题由调用此函数的地方保证)。函数❷处则负责处理当队列中没有数据时wait等待直到有线程`push()`进新的数据。在此函数中先锁定头部互斥元`head_mutex`，然后判断是否需要等待通知(此时会锁定互斥元`tail_mutex`，获取尾部数据)。待当前头部互斥元锁定成功并且不需要等待(或者收到`wait`通知)时将该互斥元锁定转移给❹或❺。在❹或❺中成功获取互斥元锁定后则可以直接读取头部数据`pop_head()`。

## 2.3 设计更复杂的基于锁的数据结构

前面示例中的`stack`和`queue`都是相对简单的数据结构，它们的接口都相对简单且有限，仅有插入数据和弹出数据两类操作。而在实际应用中我们使用的数据结构往往更为复杂，这也就使得在并发使用这些数据结构时需要考虑的问题更为复杂，本节我们将来讨论复杂数据结构的多线程并发问题。我们将以查找表的设计表示例来讨论这个问题，因为查找表数据结构不在简单的拥有增加删除类接口，它完整的涵盖了对数据操作的 增 删 改 查四个维度。

### 2.3.1 编写一个使用锁的线程安全的查找表

在C++标准库中一个最为常见的查找表就是`std::map<>`，与前面提到的队列或栈不同，查找表有增删改查四个维度的操作接口，因此在设计支持多线程并发的查找表数据结构时会变的更为复杂。 `std::map<>`就不是一个多线程并发使用下线程安全的设计，最大的问题在于迭代器，迭代器相当于是返回了数据的引用([[2. 在线程间共享数据|在线程间共享数据]]中的内容，线程安全的一个条件就是不能返回引用或者指针，这样就相当于可以绕开了互斥元锁定而修改数据)。

因此我们应该设计自己的线程安全的查找表，首先应该确保有增删改查四类操作的接口，如果坚持简单的线程安全准则，例如不返回引用，每个成员函数上都有一个互斥元等，那么这些操作接口都是线程安全的。然而如果真的这么设计明显会浪费通过独立的函数来读取数据结构并修改它们所提供的并发的可能性。因此我们仍然需要像之前对队列的世界那样使用细颗粒度锁的方式设计出支持高并发的线程安全的数据结构。

### 2.3.2 设计一个细颗粒度锁的MAP数据结构

如同本章前面提到的队列一样，为了允许细颗粒度锁，我们应该仔细考虑数据结构的细节，而不是简单封装个类似`std:map<>`的容器。通常有三种常见方式来实现一个类似查找表的容器：二叉树，例如红黑树(`std::map`采用此方案)，已排序数组和哈希表。二叉树和已排序数组并不能为多线程并发操作提供太多优势：二叉树每次查找或修改都必须从根节点开始遍历，因此需要频繁锁定根节点，这无疑限制了多线程并发执行。而已排序数组就更糟糕了，因为无法获知要操作的数据在数组的哪个位置，每次操作就不得不对整个数组进行锁定，因此也不利于并发。那么适合并发操作的就只有哈希表的实现方案了。

使用哈希表实现查找表时，假定有一定数里的数据存储桶，一个键(`key`)对应哪个桶完全取决于哈希函数的特性，这就意味这可以分别对每个桶使用一个独立的锁，这样就相当于为查找表使用N个锁进行锁定(N就是当前表中存储的数据个数)，而锁定的颗粒度就是每个存储的数据，也就也为这在访问这N个数据时时可以并发的。此时我们所剩的唯一问题就是为键值(`key`)提供一个合适的哈希函数。如下图所示的代码示例展示了如何使用一个哈希表实现线程安全又支持并发的查找表数据结构。

![[C++/C++并发编程实战/attachments/Pic_064.png]]
![[C++/C++并发编程实战/attachments/Pic_065.png]]
![[C++/C++并发编程实战/attachments/Pic_066.png]]
![[C++/C++并发编程实战/attachments/Pic_067.png]]

如上图中所示,`bucket_type`类实现了数据桶的功能，将每个`hash`值相同的数据存在一个桶的列表中，每个数据桶被一个`shared_mutex`互斥元锁定(支持同时多个读取获取一个写入)。也就是说❹❺接口为写操作会被独占使用，但❸是读取操作可以同时被多个共享读取所有权。而最外层的`threadsafe_lookup_table`则是使用一个`hash`函数来建立起整个哈希表，`hash`函数通过`key`计算出该数据存储在哪个数据桶并返回该数据桶对象❼，而在❽❾❿中对数据记性增删改查的操作。因为在该示例中哈希表中数据桶的个数是固定的19个也不会动态增加减少，因此在❼中也无需锁定哈希表。在多线程环境下调用❽❾❿接口时，如果操作的不是同一个数据桶中的数据则可以并发访问，如果是同一个数据桶中的数据调用❽接口时仍可并发访问，只有写操作调用❾❿接口时才会被独占，因此在很大程度上提供了多线程的并发支持。

### 2.3.3 编写一个使用锁的线程安全链表

上述查找表容器的设计虽然支持了并发也是线程安全的，但是它没有迭代器的支持。本节将以链表为示例设计支持迭代器的线程安全的链表类。STL风格的迭代器并不是一个很好的旋转，因为STL迭代器将持有某种对容器内部数据结构的引用，要保证线程安全就必须在迭代器持有的数据结构上加锁，而且SLT风格迭代器的生命周期是完全不受控的(取决于用户的逻辑)因此这种风格的迭代器就不是一个好的选择。

另一种方案是提供类似`for_each`的迭代函数作为容器本身的一部分，让用户的操作通过函数指针的方式传入由容器本身完全负责迭代器和锁。但此方案也不是完美的，这种做法违背了[[2. 在线程间共享数据|在线程间共享数据]]中避免死锁的原则因此需要用户规避死锁。此外对每个容器中的数据调用用户提供的方法也存在数据竞争的风险，此风险可以通过每次操作传递原始数据的一个拷贝副本的方法规避，但会带来额外的性能开销。总之使用此方案的用户需要自己避免死锁和数据竞争。

考虑到细颗粒度锁的基本思想，最简单的做法就是为每个节点使用一个互斥元，虽然这样会有很多互斥元，但好处是可以在链表不同部分的操作真正实现并发。每个操作仅在真正关注的节点上持有锁，当它移动到下一节点时，会解锁每个节点。因此一个考虑细颗粒度锁并且支持迭代器的链表实现方案如下图所示：

![[C++/C++并发编程实战/attachments/Pic_068.png]]
![[C++/C++并发编程实战/attachments/Pic_069.png]]
![[C++/C++并发编程实战/attachments/Pic_070.png]]

如上图所示，❶❷❸定义了每个数据存储节点并为每个节点设置独立的互斥元。在`push_front()`函数中先请求分配新的内存，然后锁定根节点互斥元(将内存分配放到锁定外面减少互斥元锁定时间)，待根节点被成功锁定后将新节点插入到根节点之后。如此一来`push_front()`仅影响根节点(锁定)，且将开销较大的内存分配操作放在锁定之外，即降低了根节点锁定时间又能保证其他线程并发访问操作其他节点。

再来看`for_each()`和`find_first_if()`两个函数，这两个函数的实现很类似因此我们以`for_each()`函数进行说明。在`for_each()`函数中将迭代遍历所有节点，首先在❽将根节点作为当前节点锁定，然后获取并锁定其`next`节点❾❿。待`next`节点成功锁定后释放对当前节点的锁定(步骤11)。然后取出`next`节点的数值以值传递的方式传递给用户函数f开始执行(避免传递引用导致数据竞争)。最后将`next`节点设置为当前节点并持续其锁定关系(步骤13)，继续下一个循环。`find_first_if()`基本与其类似，同一时刻最多锁定一个节点，待next节点锁定成功后立刻释放当前锁定，操作完成后将next锁定设置为当前锁定并进行下一次循环。

`remove_if()`则稍微有些不同，其不同点在于找到需要删除节点时直接修改链表指向并解锁要删除的节点。总之以上的这种设计为每个节点设立单独的互斥元，在操作时尽量少的锁定节点(每次操作锁定一个)可以在最大限度上保证并发，而且通过`for_each()`也实现了支持链表的迭代操作。而线程安全方面由于每个操作在任意时刻都只会锁定一个互斥元因此不会有死锁的问题，而且迭代其中传递的是值拷贝而非引用，也保证了数据访问的线程安全。