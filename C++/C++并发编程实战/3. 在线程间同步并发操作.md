---
tags:
  - cplusplus
---

# 1. 线程间操作同步概述

在上一章中我们讨论了如何在多个线程之间共享数据，本章我们将讨论如何在线程之间同步操作。在实际的功能开发中经常会遇到这种情况：A线程需要等待B线程执行到一个特定时机后继续进行(eg: A线程需要等待B线程资源加载完成后继续初始化后续操作)。当然通过使用共享数据的方式(A线程每帧检测共享数据，B线程完成操作后设置共享数据)也是可以达到此目的的，但是A线程不断的检测共享数据就需要不断的对互斥元锁定/解锁范围会降低整体的执行效率，如果定时检测(例如100ms检测一次)虽然提升了执行效果，但是无法保证B线程完成后A线程立刻执行(存在100ms的误差)。此时更为合适的方式就是在线程之前使用类似事件的方式完成多线程间的同步操作，这也就是本章讨论的重点内容。

# 2. 等待事件或者其他条件

C++标准库提供一套**条件变量**的机制用于解决这种线程间同步操作的需要，这也是我们处理此类问题的首要选择。从概念上说，条件变量与某些事件或其他条件相关，并且一个或多个线程可以等待该条件被满足。当某个线程已经确定条件得到满足，它就可以通知这一个或多个正在条件变量上进行等待的线程，以便唤醒它们并让它们继续处理。

## 2.1 用条件变量等待条件

C++标准库提供了两个条件变量实现线程间同步事件：`std::condition_variable`和`std::condition_variable_any`。两者用法基本类似都需要与互斥元配合使用，前者`std::condition_variable`只能与`std::mutex`一起工作，而后者则可以与符合成为类似互斥元的最低标准 的任何东西一起工作，因此以any为后缀。使用时应首选`std::condition_variable`(性能开销较低)，除非因灵活性需要。本节将以`std::condition_variable`为例，讨论其具体用法，`std::condition_variable_any`用法与之相类似。

`std::condition_variable_any`有两个重要函数`notfiy(notify_one / notify_all)`和`wait`函数。当某线程调用`wait`函数时，如果其判定函数(无判定函数则默认挂起)返回`false`则将线程挂起等待`notify`事件并解锁互斥元，如果判定函数为`true`或者收到其他线程的`notify`通知则唤醒当前线程并保持互斥元继续锁定状执行后续逻辑。`notify`系列函数则是负责唤醒被挂起的线程。一个具体的应用示例如下图所示：

![[C++/C++并发编程实战/attachments/Pic_027.png]]

❶处定义了一个在两个线程共享的数据队列，❷❸处为A线程中不断向数据队列中填充数据，填充数据前先将互斥元锁定，每次填充完成后都会由`std::condition_variable`发送`notify`通知其他线程数据填充完成。B线程负责等待处理队列中的数据，在❹处先用`std::unique_lock`锁定互斥元(之所以使用`std::unique_lock`锁定是因为在`wait`函数及后续逻辑中可以随时`unlock`互斥元，使用`std::guard`无法做到这一点参见上一章内容)。❺处调用wait接口，因该互斥元和判定条件函数(`lambda`函数)为参数。等待队列数据填充。如果当前队列中有数据或者接到A线程通知，则唤醒B线程，保持互斥元锁定继续后续执行。如果判定条件函数返回`false`，则挂起B线程并释放互斥元。❻处之所以解锁互斥元，是为了保持适当的锁定颗粒度，因为处理数据函数`process()`可能开销很高，此时完全没有必要锁定互斥元导致其他线程的挂起等待。

使用`notify_one()`或`notify_all()`可以通知所有或者某一个(不确定的一个)等待线程唤醒执行。但是如果等待线程的逻辑仅会被唤醒一次(唤醒一次后不再响应)，或者所等待的条件是一个特定数据块的可用性，那么此时条件变量可能就不再使用，此时更适合使用期望(`future`)，我们将在下节中讨论`future`的用法。

## 2.2 使用future等待一次性事件

很多时候我们需要的情景是B线程等待A线程的事件通知，该通知会且仅会通知一次并且通知时可能还会带有额外的数据通知信息。例如：主线程通过资源线程加载某资源，主线程会等待资源线程加载完成的通知(这个通知只会来一次)，并且会将加载好的资源带回给主线程。C++标准库使用`future`类处理类一次性事件，`future`类有两种：唯一`future(std::future<>)`和共享`future`(`std::shared_futures<>`)。共享的意思类似于共享指针，本质上都是同一个`future`但可以被不同的线程持有等待。本节将讨论`future`的几种具体应用场景。

### 2.2.1 std::async与future配合使用

`future`的第一种应用场景即是与异步任务`(std::async)`配合使用，异步执行某一具体功能/任务并通过`future`将执行结果返回。一个异步任务`(std::async)`与`future`配合使用的示例如下图所示：

![[C++/C++并发编程实战/attachments/Pic_028.png]]
![[C++/C++并发编程实战/attachments/Pic_029.png]]
![[C++/C++并发编程实战/attachments/Pic_030.png]]

如上图中的❶❷所示，`std::async`的用法与`std::thread`类似，将入口函数作为第一个参数，入口函数的参数为后续参数。与`std::thread`不同的是`std::async`可以利用`std::future<>`将异步执行的函数返回值带回调用线程。❶中的f1类型为`std::future<void>`表示无返回值的一个期望，❷中的f2类型则为`std::future<std::string>`表示返回一个类型为字符串的期望，并可以通过`f2.get()`来获取到异步执行结果的字符串返回值。

此外`std::async`任务是否在一个新的线程中执行，合适执行等细节是可以通过`std::launch`控制的，如上图中的❸❹所示，s`td::launch::async`标识当前任务在一个新的线程中执行(换句话说，此任务也可以在当前线程中执行)，`std::launch::deferred`则表示对入口函数的调用为延迟调用，直到在`furture`上调用`get()`或者`wait()`时才真正调用任务的入口函数，如上图中❺所示。

### 2.2.2 std::packaged_task与future关联使用

`std::packaged_task<>`模板类是一个以函数类型为模板的类，它将`future`绑定到一个函数或者可调用对象上，当`std::packaged_task<>`对象被调用时，它或执行与之绑定的函数将结果存储到`future`中并通知`future`准备就绪。这样讨论可能过于抽象，让我们来看下绑定以`std::vecor<char>* `和`int`为参数返回值为`std::string`的函数的示例：

![[C++/C++并发编程实战/attachments/Pic_031.png]]

上图中❶处定义了该模板类型为一个形如`std::string Fuction(std::vector<char>*, int)`的函数。❷表示此特化`std::packaged_task<>`类的构造函数为一个此类型(`std::string Fuction(std::vector<char>*, int)`)的函数指针作为任务入口函数。❸为此特化`std::packaged_task`类获取`future`对象，此处获取的`future`对象为`std::future<std::string>`类型，用于返回入口函数的返回值。❹处重载()操作符直接调用入口函数，并将结果存入`future`中。

如下图所示展示里一个利用`std::packaged_task`和`future`配合使用的示例，这个示例是某`GUI`框架中的一部分，该`GUI`框架要求所有`GUI`的更新必要有特定的一个线程来统一执行。也就是说当主线程需要更新`GUI`时必须通知`GUI`线程来执行具体操作，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_032.png]]

如上图所示定义了一个等待在gui线程执行的任务队列`std::deque<std::packaged_task<void()>>`(要执行的任务入口为一个无需参数且无返回值的函数)，同时定义了一个互斥元`std::mutex m；`用于在`gui`线程和主线程操作任务队列时对其进行锁定。❶~❻为`gui`线程处理逻辑：❶为`GUI`线程处理的入口。❷检测`GUI`是否关闭。 ❸获取并处理`GUI`消息。❹锁定互斥元，如果任务列表为空则解锁并返回。❺从任务列表中获取任务信息并`move`到`task`(`std::packaged_task`可移动不可复制)。❻ 执行任务task(也就是执行主线程中设置的任务入口函数)。❼~❿则是主线程填充要执行`GUI`的过程，❼为定义一个任务入口函数是`f`，函数类型是无参数无返回值类型函数。❽获取该任务对于的`feture`。❾锁定互斥元并向任务列表中添加此任务(不支持复制，只能`move`移动)。❿将该任务对于的`feture`返回给逻辑层，用于处理等待任务执行结果并获取任务返回值(此处无返回值)。

### 2.2.3 承诺(std::promise)与预期(std::future)

`future`和`promise`的作用是在不同线程之间传递数据。两者配合使用，使用方式如下：

- 线程1初始化一个`promise`对象和一个`future`对象，并将`promise`传递给线程2，相当于线程2对线程1的一个承诺；`future`相当于一个接受一个承诺，用来获取未来线程2传递的值

- 线程2获取到`promise`后，需要对这个`promise`传递有关的数据，之后线程1的`future`就可以获取数据了。

- 如果线程1想要获取数据，而线程2未给出数据，则线程1阻塞，直到线程2的数据到达

其配合使用的工作流程如下图所示：

![[C++/C++并发编程实战/attachments/Pic_033.png]]

`std::promise`和`std::future`配合使用的一个示例如下图所示：

![[C++/C++并发编程实战/attachments/Pic_034.png]]

其中❶为线程入口函数。❷让该线程`sleep``1000ms`。❸在子线程中填充承诺`std::promise`值。❹为主线程中创建数据为`int`型的承诺(`std::promise`)对象。❺在主线程中有当前承诺获取其对应的预期(`std::future`)。❻创建子线程并设置其入口函数开始执行。❼从预期(`std::future`)中获取值，如果对青的承诺(`std::promise`)尚未填充则此现场被挂起等待。❽将子线程`join`到主线程，主线程等待子线程执行完成后才继续。此段代码只完成后的日志顺序为： `In a thread, making data... Finished 35`

### 2.2.4 预期(std::future)的异常情况

我们了解了`std::future`常见的三种用法，在这里我们要多一点思考，如果当主线程挂起等待`std::future`时，在子线程中执行代码发生异常时会怎么样。如下图所示：

![[C++/C++并发编程实战/attachments/Pic_035.png]]
![[C++/C++并发编程实战/attachments/Pic_036.png]]

当在子线程中执行`square_root`函数时，如果参数小于零则会引发异常，此时主线程并不会立刻引发异常，而是会将异常因袭保存在`std::future`中，并当在主线程调用`f.get()`函数时将异常抛出。同理当使用`std::promise`时也是如此，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_037.png]]

在`std::promise`中执行成功时设置数据，执行失败时设置异常。即使设置异常也会通知`future`变为就绪，当调用`get()`获取数据时再将异常抛出。

这种情况较为好处理，因为虽然子线程执行时发生了"故障"，但在主线程调用`std::future`返回值时仍然会将异常抛出。但是如果`std::promise`等方式在子线程中填充预期`(std::future`)数据前就被销毁，则`std::future`永远不会就绪，也就是说主线程可能永远处于等待。这是我们编码时需要特别注意的。

### 2.2.5 在多个线程内等待

前面我们讨论的`std::future`都是在A线程中等待B线程执行完成并返回数据。但是如果你的代码结构设计为需要在A线程 B线程同时等待C线程执行完成并返回数据，如果不对`std::future`对象做额外的同步，则此时在两个线程之间对s`td::future`对象访问仍然存在竞争关系。因此在这种情况下就需要使用之前提到过的共享预期`std::shared_future`。前面有提到`std::future`仅为可移动(`std::move`转移所有权)都并非可复制的，但`std::shared_future`对象是可复制的，并且这复制后的多个对象引用一个相同的状态。

使用`std::shared_future`对象解决多个线程等待的问题本质上就是利用了其可复制的特点，复制出多个`std::shared_future`对象避免竞争条件(由于每个复制对象的内部都引用了同一个状态，并且内部已做过处理)，这样才能保证避免竞争条件的同时，又能保证在多个线程中获取到相同数据的引用。如下图所示：

![[C++/C++并发编程实战/attachments/Pic_038.png]]

# 3. 有时间限制的等待

前面提到的所有阻塞等待都是无限期的等待直到事件通知或者预期达成，但某些情况下我们需要对等待/挂起时间做个限制。C++标准库提供了两种可指定的超时：一种为基于时间段的超时，另一种为指定到达时间点为超时时间。因此等待事件通知或者预期达成的接口`wait`都有额外的两个重载版本`wait_for()`用于指定等待多长时间，`wait_until()`函数则用于指定等待到某时间点。

## 3.1 时钟(Clock)

无论是等待一段时间还是等待到某一时刻，都需要有一个关于时间的表达，就C++标准库而言时钟是时间信息的来源。时钟可以提供四个不同的信息类：当前时间(now)，用于表示获取时间值的类型，时钟的节拍周期以及当前时钟是否是匀速时钟。

更具体的说可以使用`std::chrono::system_clock::now()`来返回系统时钟的当前时间。对于具体某个时钟的某个时间点类型，是可以通过`time_point`成员的`typedef`来指定的。因此某类型的时钟`std::xxx::now()`返回的类型是`xxx::time_point`类型。时钟的节拍周期表达的是时钟的频率，例如`::std::ratio<1，25>`表示1秒25次的时钟也就是0.25s一个周期，同理`std::ratio<5,2>`表示5s两个周期也就是说每2.5s为一个周期。每个时钟类有个`is_steady`成员标识其是否以均匀速率计时，例如：`std::chrono::system_clock`是不匀速的。也就是说该时钟是会自动调整频率的，因此该时钟调用`now()`的返回值有可能比之前调用`now()`的值更早。而`std::chrono::steady_clock`为均匀时钟。

**注：之所以先介绍时钟，是因为时钟是后续讨论时间段和时间点的基础。**

## 3.2 时间段

时间段是时间支持中最简单的部分，由模板类`std::chrono::duration<>`模板类表示。该模板类的第一个模板表示的是类型，第二个模板则是表示时间周期，例如：`std::chrono::duration<float,std::ratio<1,1000>>`表示的是该时间段数值用float型表示，而其表示的时间段单位是毫秒`ms`(1s 1000个周期)。此外系统还为常用的时间单位提供了一组预定义：`typedef: nanoseconds`(纳秒), `miscroseconds`(微秒), `milliseconds`(毫秒)，`seconds`(秒)等。不同单位之间的转化还可以使用`std::chrono::duration_cast<>`来实现，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_039.png]]

而之前提到的有时间限制的等待，则可以通过`std::chrono::duration<>`来实现，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_040.png]]

## 3.3 时间点

时间点是可以通过std::chrono::time_point<>类模板实例来表示，其第一个模板参数指定其所参考的时钟类型，第二个参数则指定计量单位。时间点的值时时间的长度，以此一个特定的时间点又被称为时钟的纪元(epoch)。例如：std::chrono::time_point<std::chrono::system_clock,std::chrono::minutes>表示该时间点与系统时钟相关，且其表达的单位是以分钟为精度进行测量的。当然我们也可以用一个时间点加减一个时间段来表示一个新的时间点例如：std::chrono::high_resolution_clock::now()+std::chrono::nanoseconds(500)表示从现在开始500ns后的时间点。等待一个具有超时时间点的条件变量的示例代码如下图所示：