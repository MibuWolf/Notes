---
tags:
  - cplusplus Concurrent Parallel
---

# 1. 概述

在了解多线程前，我们先来回顾下并发与并行：

**并发（Concurrent）**：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其本质上是通过操作系统的调度在一段时间内分别执行这几个不同的程序

**并行（Parallel）**：当系统有一个以上CPU(或者一个CPU有多个核心)时，当一个CPU执行一个操作时，另一个CPU可以执行另一个操作，两个操作互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

如下图所示两者的对比：

![[C++/C++并发编程实战/attachments/Pic_001.png]]

由此可见使用多线程将任务并行执行可以大幅提升运行时的执行效率。本章将接受如何在C++中使用和管理线程。

# 2. C++中的多线程

## 2.1 C++中多线程的基本用法

在C++11标准中增加了多线程的概念，其用法也很简单如下图程序所示：

![[C++/C++并发编程实战/attachments/Pic_002.png]]

❶表示的是包含C++线程头文件，❷处为线程入口执行函数，❸处为主线程创建一个新的线程并以`hello`函数作为新的线程入口函数。❹处的`join`函数表示此处需要等待t线程执行完成(t线程执行完成前不会执行后续操作) 如果不需要等待该线程执行完成则可以使用`detach()`函数。注意：每个线程t只能被join一次可以通过`joinable()`函数判定当前是否可被`join`。

入口函数可以有多种书写方式除了上述这种传统函数定义方式外也可以直接使用Lambda表达式的方式如下图所示：

![[C++/C++并发编程实战/attachments/Pic_003.png]]

与许多C++标准库类似，`std::thread`可以与任何可调用(`callable`) 类型一同工作，所以我们也可以 将一个带有函数调用操作符的类的实例传递给`std:: thread`的构造函数来来代替线程的入口函数。如下图所示：

![[C++/C++并发编程实战/attachments/Pic_004.png]]

**注：具体使用哪种方式要看实际中要处理的内容，根据具体情况选择最合适的方式。**

## 2.2 传递参数给线程入口函数

既然C++中是通过定义线程入口函数来创建新的线程，那么就会涉及到线程入口函数的参数传递。传递参数的方式很简单：在创建线程时直接以参数的形式传递给`std:thread`即可，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_005.png]]

如上图所示，在❶处定义线程入口函数的参数，❷处创建线程并将参数一并传入。但是这里存在一个问题，此处的参数传递默认是以复制拷贝的方式进行的，也就是说参数 `buffer`会被复制到临时变量`temp`并将临时变量`temp`传递该线程入口函数。而当前线程是`detach`的，也就是说主线程无需等待此线程执行完成，此时buffer数组是个局部变量，在子线程中使用临时变量`temp`给`std::string`传递数据时可能主线程的buffer局部变量已经被释放，此时`temp`指向的是一块无效的地址。因此未解决此问题最好的办法是在传递参数前将`buffer`指针转化为`std::string`。并将整个`std::string`进行复制拷贝，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_006.png]]

***注：这样修改后相当于直接将参数std::string类型进行拷贝而非仅将数组地址进行复制。***

由上述示例可见传递和复制的是主线程中的数据类型，而并非先将主线程数据类型强转为线程入口函数中的参数类型后再传递，也就是说如果类型不一致，强转是发生在子线程中进行的。这同时导致一个新的问题，当你使用引用作为参数类型并希望通过引用返回子线程执行结果时，你的希望可能会落空，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_007.png]]

在❶处定义线程入口函数，参数为`widget_data`的引用类型，❷处将主线程的数据以参数形式传递给子线程入口函数。❸处期望获得子线程对`widget_data`处理后的结果，但此时实际上数据并未发生变化。这是因为在❷处传递参数时会发生拷贝复制，会将一个拷贝复制后的临时变量`temp`传递给子线程入口函数，而在子线程入口函数将其参数隐式转换为`widget_data`引用的目标对象式`temp`对象而非原始的`data`对象。因此子线程中持有的并非原始数据`data`的引用，从而对其的一切修改都不会影响原始的`data`数据。

如果真的需要从子线程以引用的方式返回参数数据，则可以使用`std::ref`，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_008.png]]

除了上述的入口函数及参数的传递方式外，还可以以成员函数的方式传递，如下图所示：

![[C++/C++并发编程实战/attachments/Pic_009.png]]

在❶中将X类的成员函数`do_lengthy_work`作为线程入口函数，将X对象的地址作为参数传入，其含义是将在子线程中调用`my_X`对象的`do_lengthy_work`函数作为线程入口函数。

## 2.3 转移线程所有权

在使用多线程时经常会遇到需要将线程所有权转移的情况，例如：A创建并启动了线程，而在等待线程执行完成的B处需要使用此线程。此时就需要将线程的所有全从A转移到B。`std::thread`是可移动(`movable`)但不可复制(`copyable`)的，这也就意味之线程所有权可以进行转移但是不能复制。

![[C++/C++并发编程实战/attachments/Pic_010.png]]

如上图中的示例很好的解释了线程所有权的转移而非复制的过程，在❶中创建了一个线程`X`，❷使用`std::move`显式的将该`t1`的线程所有权转移给`t2`，此时`t1`已经不再拥有任何线程。❸处又创建了一个新的线程`Y`，此时通过赋值运算符`"="`将线程Y的所有权转移给t1。❹处默认构造出`t3`意味着它没有与任何相关联的执行线程，在❺处又将X线程的所有权从`t2`转移到`t3`，❻处尝试将X线程所有权从t3转移到t1，但是此时t1已经持有了Y线程的所有权因此会调用`std::terminate()`函数抛出异常来终止程序执行。

***注：除了直接持有线程所有权，也可以通过线程ID的方式进行一些逻辑判断，eg:判断是否是同一线程，或者检测某一线程是否需要执行一些操作等。***