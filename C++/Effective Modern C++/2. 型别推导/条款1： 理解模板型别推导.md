---
tags:
  - c++ template auto decltype
---

# 1. 概述

在C++98中仅有一套型别(类型)推导规则既：模板。C++11对这套规则进行了一些改动并增加了两套规则：auto和decltype。这些型别(类型)推导使得我们不必再去写那些不言自明或者完全冗余的型别(类型)，同时还可以让我们的C++代码具有更高的适应性，仅需在源代码修改变量类型就可以自动的传播到其他使用的地方。

此外，了解有关型别(类型)推导相关的规则也能帮我们增强对代码的掌控，清晰明确的知道每个型别(类型)的推导结果将有利于我们写出更加安全强壮的代码。

# 2. 条款1： 理解模板型别推导

## 2.1 概述

模板是C++程序员经常用到的一个特性，成千上万的程序员都向函数模板传递实参并获得了令人满意的结果，而这些人中却有很多人对所使用的函数模板在运行时的类型模糊不清更不用说了解这些参数被推导出来的过程了。本条款将详细讨论模板是如何推导出参数类型的，在开始讨论前在此先将后续使用的伪代码做个格式说明，如下所示：

``` C++ 伪代码

template<typename T>     // 此处用typename为作者个人偏好写成class也是一样的
void f(ParamType param); // ParamType为模板函数形参类型的定义也可以写成T

f(expr);                 // 此处为对模板的一次调用，expr为调用是传入的参数

```

## 2.2 情况1：ParamType是个指针或引用，但不是万能引用

关于[[6 右值引用,移动语义和完美转发#3. 区分万有引用和右值引用|万有引用]]我们将在后续章节详细讨论，此处先有个基本印象即可。

最简单的莫过于当***ParamType***是个指针或者引用但不是万能引用的情形了，在这种情况下，型别(类型)推导会这样运作：

- 若***expr***需要引用/指针型别(类型)，先将引用/指针部分忽略。
- 然后对***expr***的型别(类型)和***ParamType***的型别(类型)执行模式匹配，来决定 ***T*** 的型别(类型)。

如下示例所示：

``` C++ 伪代码

template<typename T>     
void f(T& param);        // 函数模板中参数使用的是个引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // 此时T的类型为int 形参param的类型是int&

f(cx);               // 此时T的类型是const int 形参param的类型是const int&

f(rx)      // 此时T的类型是const int(由上述规则先排除引用部分) 形参param的类型是const int&

```

此处需要注意的是：当模板中的形参是引用/指针时，调用该模板函数时传入的参数若是***const***类型那么它是安全的，也就是说传入对象的***const***修饰会被型别(类型)推导保留成为推导结果的组成部分。而其他类型的模板参数定义则不一定如此，详见下文。

上述示例代码是以引用为例，其实形参定义成指针结果也是一样的，如下伪代码所示：

``` C++ 伪代码

template<typename T>     
void f(T* param);        // 函数模板中参数使用的是个指针 param为形参名

int x = 27;              // x的类型是int
const int* px = &x;      // px是指向x的指针，其型别(类型)为const int

f(&x);                // 此时T的类型为int 形参param的类型是int*

f(px)      // 此时T的类型是const int(由上述规则先排除引用部分) 形参param的类型是const int*

```

但当我们将形参***param***的类型从***T&/T\**** 改为***const T&/ const T\**** 时，结果会有一点变化，但仍符合上述推导规则，如下伪代码所示：

``` C++ 伪代码

template<typename T>     
void f(const T& param);        // 函数模板中参数使用的是个引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // 此时T的类型为int 形参param的类型是const int&

f(cx);               // 此时T的类型是int 形参param的类型是const int&

f(rx)      // 此时T的类型是int(由上述规则先排除引用部分) 形参param的类型是const int&

```

此时调用该模板函数时，若传入的参数本身就带有const则此时的const将被认定为模板形参中的const因此在推导形参T的类型时将不再考虑const。

## 2.3 情况2：ParamType是个万能引用

对于持有万能引用形参的模板而言，规则就变得不那么明显了。此类形参的声明方式类似右值引用(即在模板中定义的形参写作 ***T&&***)，此时在调用传参时会根据参数是左值/右值而有所不同，具体细节参见[[6 右值引用,移动语义和完美转发#3. 区分万有引用和右值引用|万有引用/右值引用]]，此处给出基本规则：

- 若***expr***是个左值则 ***T*** 和 ***ParamType*** 都会被推导为左值引用。这样的推导比较特别：首先它比较反直觉，在模板声明的形参是右值引用的语法形式但推导结果却是左值引用。其次，这也是模板推导中唯一会把类型***T***推导为引用的情形。
- 若***expr***是个右值，则按照正常直觉推导即：按照**情况1**的规则推导。

如下伪代码示例所示：

``` C++ 伪代码

template<typename T>     
void f(const T&& param);        // 函数模板中参数使用的是个万能引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // x是左值因此此时T的类型为int& 形参param的类型是int&

f(cx);               // cx是左值因此此时T的类型是const int& 形参param的类型是const int&

f(rx)      // rx是左值因此此时T的类型是const int& 形参param的类型是const int&

f(27);     // 27是右值因此此时T的类型是int 形参param的类型是int&&

```

## 2.4 情况3：ParamType即非指针也非引用

当***ParamType***既不是指针也不是引用时，我们通过值传递的方式处理，这意味着无论传递什么***param***都会成为它的一份拷贝——一个完整的新对象。这种情况也是我们使用最多的情形，型别(类型)推导会这样运作：

- 若***expr***的类型是一个引用则忽略引用部分。
- 若忽略引用部分后***expr***仍被const/volatile()修饰，则也忽略const/volatile。

实际上我们使用这种非指针非引用的值传递模板的情况最为普遍，接下来我们将从三种场景的情景分别讨论以帮助我们更加直观的理解。

### 普通类型实参

所谓普通类型实参指的是调用模板函数时传入的参数为一个普通的常见数据类型（结构体，类，基础类型以及其引用指针等），如下示例所示：

``` C++ 伪代码

template<typename T>     
void f(T param);        // 函数模板中参数既非指针也非引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // 此时T的类型为int 形参param的类型也是int
f(cx);               // 此时T的类型为int 形参param的类型也是int
f(rx)      // 此时T的类型为int 形参param的类型也是int

```