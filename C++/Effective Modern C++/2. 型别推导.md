---
tags:
  - c++ template auto decltype
---

# 1. 概述

在C++98中仅有一套型别(类型)推导规则既：模板。C++11对这套规则进行了一些改动并增加了两套规则：auto和decltype。这些型别(类型)推导使得我们不必再去写那些不言自明或者完全冗余的型别(类型)，同时还可以让我们的C++代码具有更高的适应性，仅需在源代码修改变量类型就可以自动的传播到其他使用的地方。

此外，了解有关型别(类型)推导相关的规则也能帮我们增强对代码的掌控，清晰明确的知道每个型别(类型)的推导结果将有利于我们写出更加安全强壮的代码。

# 2. 条款1： 理解模板型别推导

## 2.1 概述

模板是C++程序员经常用到的一个特性，成千上万的程序员都向函数模板传递实参并获得了令人满意的结果，而这些人中却有很多人对所使用的函数模板在运行时的类型模糊不清更不用说了解这些参数被推导出来的过程了。本条款将详细讨论模板是如何推导出参数类型的，在开始讨论前在此先将后续使用的伪代码做个格式说明，如下所示：

``` C++ 伪代码

template<typename T>     // 此处用typename为作者个人偏好写成class也是一样的
void f(ParamType param); // ParamType为模板函数形参类型的定义也可以写成T

f(expr);                 // 此处为对模板的一次调用，expr为调用是传入的参数

```

## 2.2 情况1：ParamType是个指针或引用，但不是万能引用

关于[[6 右值引用,移动语义和完美转发#3. 区分万有引用和右值引用|万有引用]]我们将在后续章节详细讨论，此处先有个基本印象即可。

最简单的莫过于当***ParamType***是个指针或者引用但不是万能引用的情形了，在这种情况下，型别(类型)推导会这样运作：

- 若***expr***需要引用/指针型别(类型)，先将引用/指针部分忽略。
- 然后对***expr***的型别(类型)和***ParamType***的型别(类型)执行模式匹配，来决定 ***T*** 的型别(类型)。

如下示例所示：

``` C++ 伪代码

template<typename T>     
void f(T& param);        // 函数模板中参数使用的是个引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // 此时T的类型为int 形参param的类型是int&

f(cx);               // 此时T的类型是const int 形参param的类型是const int&

f(rx)      // 此时T的类型是const int(由上述规则先排除引用部分) 形参param的类型是const int&

```

此处需要注意的是：当模板中的形参是引用/指针时，调用该模板函数时传入的参数若是***const***类型那么它是安全的，也就是说传入对象的***const***修饰会被型别(类型)推导保留成为推导结果的组成部分。而其他类型的模板参数定义则不一定如此，详见下文。

上述示例代码是以引用为例，其实形参定义成指针结果也是一样的，如下伪代码所示：

``` C++ 伪代码

template<typename T>     
void f(T* param);        // 函数模板中参数使用的是个指针 param为形参名

int x = 27;              // x的类型是int
const int* px = &x;      // px是指向x的指针，其型别(类型)为const int

f(&x);                // 此时T的类型为int 形参param的类型是int*

f(px)      // 此时T的类型是const int(由上述规则先排除引用部分) 形参param的类型是const int*

```

但当我们将形参***param***的类型从***T&/T\**** 改为***const T&/ const T\**** 时，结果会有一点变化，但仍符合上述推导规则，如下伪代码所示：

``` C++ 伪代码

template<typename T>     
void f(const T& param);        // 函数模板中参数使用的是个引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // 此时T的类型为int 形参param的类型是const int&

f(cx);               // 此时T的类型是int 形参param的类型是const int&

f(rx)      // 此时T的类型是int(由上述规则先排除引用部分) 形参param的类型是const int&

```

此时调用该模板函数时，若传入的参数本身就带有const则此时的const将被认定为模板形参中的const因此在推导形参T的类型时将不再考虑const。

## 2.2 情况2：ParamType是个万能引用

