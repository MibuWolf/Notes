---
tags:
  - c++ template auto decltype
---

# 1. 概述

在C++98中仅有一套型别(类型)推导规则既：模板。C++11对这套规则进行了一些改动并增加了两套规则：auto和decltype。这些型别(类型)推导使得我们不必再去写那些不言自明或者完全冗余的型别(类型)，同时还可以让我们的C++代码具有更高的适应性，仅需在源代码修改变量类型就可以自动的传播到其他使用的地方。

此外，了解有关型别(类型)推导相关的规则也能帮我们增强对代码的掌控，清晰明确的知道每个型别(类型)的推导结果将有利于我们写出更加安全强壮的代码。

# 2. 条款1： 理解模板型别推导

## 2.1 概述

模板是C++程序员经常用到的一个特性，成千上万的程序员都向函数模板传递实参并获得了令人满意的结果，而这些人中却有很多人对所使用的函数模板在运行时的类型模糊不清更不用说了解这些参数被推导出来的过程了。本条款将详细讨论模板是如何推导出参数类型的，在开始讨论前在此先将后续使用的伪代码做个格式说明，如下所示：

``` C++ 伪代码
template<typename T>     // 此处用typename为作者个人偏好写成class也是一样的
void f(ParamType param); // ParamType为模板函数形参类型的定义也可以写成T

f(expr);                 // 此处为对模板的一次调用，expr为调用是传入的参数
```

## 2.2 情况1：ParamType是个指针或引用，但不是万能引用

关于[[6 右值引用,移动语义和完美转发#3. 区分万有引用和右值引用|万有引用]]我们将在后续章节详细讨论，此处先有个基本印象即可。
