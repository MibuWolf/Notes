---
tags:
  - cplusplus auto decltype
---

在前文中，我们已经详细讨论了：[[条款1： 理解模板型别推导|模板型别推导]]，[[条款2：理解auto型别推导|auto型别推导]] 以及 [[条款3：理解decltype|decltype型别推导]] 的具体推导规则，本文我们将讨论如何利用工具查看型别推导的结构。我们可能需要在三个不同的阶段查看型别推导结果：代码编辑阶段，编译阶段和运行时阶段，本章将讨论如何在这三个阶段查看型别推导结果。

# 1. IDE编辑器(代码编写阶段查看型别推导结果)

利用IDE编辑器可以在代码编辑阶段显示查看代码中的变量，函数，参数类型，通常我们秩序将鼠标移到变量上即可利用编辑器功能显示出该变量的类型，如下图所示：

![[C++/Effective Modern C++/attachments/Pic_001.png]]

但在代码编辑阶段利用IDE编辑器显示类型的推导结果却是存在限制的：

- 首先，我们的代码必须或多或少处于可编译状态，这是因为IDE之所以能提供这些信息是因为一个C++编译器运行于IDE中。如果这个编译器对你的代码不能做出有意义的分析或者推导，它就不会显示推导的结果。
- 其次，在代码编写阶段，利用IDE编辑器对于简单类型的推导可能可以得到令人满意的结果，但当待推导的类型比较复杂时就往往不能得到令人满意的结果了。

# 2. 编译器诊断(利用编译器诊断在编译阶段查看行型推导结果)

在编译阶段查看型别推导结果，可以利用编译器的编译报错。在特定的编译报错中，错误信息会提示我们xxx类型的某变量发生了编译错误，利用编译器的此功能我们可以输出我们想要的型别推导结果。例如可以利用下文中的代码导致编译报错，并查看报错信息：

``` C++

template<typename T>  // 例如我们可以只对TD进行声明但并不给出其
class TD;             // 定义，这样在使用此类时就会导致编译报错

const int theAnswer = 42;

auto x = theAnswer;
auto y = &theAnswer;

TD<decltype(x)> xType;              //引出包含x和y
TD<decltype(y)> yType;              //的类型的错误消息

```

当我们对上述代码在GNU和Clang环境进行编译时，就会得到如下错误信息：

``` C++

error: aggregate 'TD<int> xType' has incomplete type and 
        cannot be defined
error: aggregate 'TD<const int *> yType' has incomplete type and
        cannot be defined

```

在Microsoft的编译器下则会输出：

``` C++

error: 'xType' uses undefined class 'TD<int>'
error: 'yType' uses undefined class 'TD<const int *>'

```

除了格式不同外，几乎所有编译器都产生了类似这样有用的错误消息，在错误提示信息中会将型别推导结果输出出来，如上错误日志所示。

# 3. 运行时输出

运行时输出型别推导结果，最简单直观的一个想法就是利用标准库的`std::type_info::name` 在日志中输出参数/对象的类型，如下代码所示：

``` C++

const int theAnswer = 42;

auto x = theAnswer;
auto y = &theAnswer;

std::cout << typeid(x).name() << '\n';  //显示x和y的类型
std::cout << typeid(y).name() << '\n';

```

该方法是利用标准库 `std::type_info` 输出对象类型，调用`std::type_info::name`不保证返回任何有意义的东西(不同编辑器可能返回不同名称)。例如在GNU和Clang环境下`x`的类型会显示为”`i`“，`y`会显示为”`PKi`“，这样的输出你必须要问问编译器实现者们才能知道他们的意义：”`i`“表示”`int`“，”`PK`“表示”pointer to ~~`konst`~~ `const`“（指向常量的指针）。而Microsoft的编译器输出得更直白一些：对于`x`输出”`int`“对于`y`输出”`int const *`“。

虽然对这种简单类型的推导结果都是正确的，但这并不意味着对于复杂情况它还能正常工作：

``` C++

template<typename T>
void f(const T& param)
{
	std::cout<< "T =       " << typeid(T).name() << `\n`;   // 显示T的类型
	std::cout<< "param =      " << typeid(param).name() << `\n`; // 显示param类型
}

std::vector<Widget> createVec();   // 工厂函数

const auto vw = createVec();

if(!vw.empty())
{
	f(&vw[0]);           // 调用函数f
	...
}

```

在GNU和Clang编译器下会 产生如下的输出结果：

``` C++
T =       PK6Widget
param =       PK6Widget
```

在微软的编译器下产生的输出结果则是：

``` C++
T =       class Widget const*
param =       class Widget const*
```

基于上文中正确的输出结果，我们第一反应可能认为这个结果是正确的，但我们仔细分析后就会发现问题：`param`的类型是 `const T&`，那么 `param` 的类型怎么可能和` T` 的类型是一样的呢？

针对本案例，虽然标准库`std::type_info::name`的表现不佳，但 `Boost`的 `TypeIndex`库却能输出正确的结果：

``` C++

#include <boost/type_index.hpp>

template<typename T>
void f(const T& param)
{
	using boost::typeindex::type_id_with_cvr;
	std::cout<< "T =       " << type_id_with_cvr<T>().pretty_name() << `\n`;   // 显示T的类型
	std::cout<< "param =      " << type_id_with_cvr<decltype(param)>.pretty_name() << `\n`; // 显示param类型
}

std::vector<Widget> createVec();   // 工厂函数

const auto vw = createVec();

if(!vw.empty())
{
	f(&vw[0]);           // 调用函数f
	...
}

```

使用 `Boost` 库无论在GNU/Clang还是微软编译器下都可以产生精确输出：

```
T =       Widget const*
param =       Widget const* const&
```

这种近似的稳定固然美好，但并不意味着使用 `Boost` 库输出推导结果就是绝对完全正确的，因此本章中的三种输出推导结果的方式仅能用于辅助判断，最为重要的还是记住并理解[[条款1： 理解模板型别推导|模板推导]] [[条款2：理解auto型别推导|auto推导]] [[条款3：理解decltype|decltype推导]]中的型别推导规则。

# 4. 要点速记

- 利用IDE编辑器，编译器错误消息和Boost.TypeIndex库常常能够帮助我们查看到型别推导的结果
- 有些工具产生的结果可能无用或者不准确，因此，理解C++的型别推导规则是很有必要的