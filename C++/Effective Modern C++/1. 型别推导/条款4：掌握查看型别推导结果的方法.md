---
tags:
  - cplusplus auto decltype
---

在前文中，我们已经详细讨论了：[[条款1： 理解模板型别推导|模板型别推导]]，[[条款2：理解auto型别推导|auto型别推导]] 以及 [[条款3：理解decltype|decltype型别推导]] 的具体推导规则，本文我们将讨论如何利用工具查看型别推导的结构。我们可能需要在三个不同的阶段查看型别推导结果：代码编辑阶段，编译阶段和运行时阶段，本章将讨论如何在这三个阶段查看型别推导结果。

# 1. IDE编辑器(代码编写阶段查看型别推导结果)

利用IDE编辑器可以在代码编辑阶段显示查看代码中的变量，函数，参数类型，通常我们秩序将鼠标移到变量上即可利用编辑器功能显示出该变量的类型，如下图所示：

![[C++/Effective Modern C++/attachments/Pic_001.png]]

但在代码编辑阶段利用IDE编辑器显示类型的推导结果却是存在限制的：

- 首先，我们的代码必须或多或少处于可编译状态，这是因为IDE之所以能提供这些信息是因为一个C++编译器运行于IDE中。如果这个编译器对你的代码不能做出有意义的分析或者推导，它就不会显示推导的结果。
- 其次，在代码编写阶段，利用IDE编辑器对于简单类型的推导可能可以得到令人满意的结果，但当待推导的类型比较复杂时就往往不能得到令人满意的结果了。

# 2. 编译器诊断(利用编译器诊断在编译阶段查看行型推导结果)

在编译阶段查看型别推导结果，可以利用编译器的编译报错。在特定的编译报错中，错误信息会提示我们xxx类型的某变量发生了编译错误，利用编译器的此功能我们可以输出我们想要的型别推导结果。例如可以利用下文中的代码导致编译报错，并查看报错信息：

``` C++

template<typename T>  // 例如我们可以只对TD进行声明但并不给出其
class TD;             // 定义，这样在使用此类时就会导致编译报错

const int theAnswer = 42;

auto x = theAnswer;
auto y = &theAnswer;

TD<decltype(x)> xType;              //引出包含x和y
TD<decltype(y)> yType;              //的类型的错误消息

```

当我们对上述代码在GNU和Clang环境进行编译时，就会得到如下错误信息：

``` C++

error: aggregate 'TD<int> xType' has incomplete type and 
        cannot be defined
error: aggregate 'TD<const int *> yType' has incomplete type and
        cannot be defined

```

在Microsoft的编译器下则会输出：

``` C++

error: 'xType' uses undefined class 'TD<int>'
error: 'yType' uses undefined class 'TD<const int *>'

```

除了格式不同外，几乎所有编译器都产生了类似这样有用的错误消息，在错误提示信息中会将型别推导结果输出出来，如上错误日志所示。

# 3. 运行时输出

运行时输出型别推导结果，最简单直观的一个想法就是li'y