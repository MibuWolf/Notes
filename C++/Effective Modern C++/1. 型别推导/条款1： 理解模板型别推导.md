---
tags:
  - cplusplus template
---

# 1. 概述

模板是C++程序员经常用到的一个特性，成千上万的程序员都向函数模板传递实参并获得了令人满意的结果，而这些人中却有很多人对所使用的函数模板在运行时的类型模糊不清更不用说了解这些参数被推导出来的过程了。本条款将详细讨论模板是如何推导出参数类型的，在开始讨论前在此先将后续使用的伪代码做个格式说明，如下所示：

``` C++ 伪代码

template<typename T>     // 此处用typename为作者个人偏好写成class也是一样的
void f(ParamType param); // ParamType为模板函数形参类型的定义也可以写成T

f(expr);                 // 此处为对模板的一次调用，expr为调用是传入的参数

```

# 2. 情况1：ParamType是个指针或引用，但不是万能引用

关于[[6 右值引用,移动语义和完美转发#3. 区分万有引用和右值引用|万有引用]]我们将在后续章节详细讨论，此处先有个基本印象即可。

最简单的莫过于当***ParamType***是个指针或者引用但不是万能引用的情形了，在这种情况下，型别(类型)推导会这样运作：

- 若***expr***需要引用/指针型别(类型)，先将引用/指针部分忽略。
- 然后对***expr***的型别(类型)和***ParamType***的型别(类型)执行模式匹配，来决定 ***T*** 的型别(类型)。

如下示例所示：

``` C++ 伪代码

template<typename T>     
void f(T& param);        // 函数模板中参数使用的是个引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // 此时T的类型为int 形参param的类型是int&

f(cx);               // 此时T的类型是const int 形参param的类型是const int&

f(rx)      // 此时T的类型是const int(由上述规则先排除引用部分) 形参param的类型是const int&

```

此处需要注意的是：当模板中的形参是引用/指针时，调用该模板函数时传入的参数若是***const***类型那么它是安全的，也就是说传入对象的***const***修饰会被型别(类型)推导保留成为推导结果的组成部分。而其他类型的模板参数定义则不一定如此，详见下文。

上述示例代码是以引用为例，其实形参定义成指针结果也是一样的，如下伪代码所示：

``` C++ 伪代码

template<typename T>     
void f(T* param);        // 函数模板中参数使用的是个指针 param为形参名

int x = 27;              // x的类型是int
const int* px = &x;      // px是指向x的指针，其型别(类型)为const int

f(&x);                // 此时T的类型为int 形参param的类型是int*

f(px)      // 此时T的类型是const int(由上述规则先排除引用部分) 形参param的类型是const int*

```

但当我们将形参***param***的类型从***T&/T\**** 改为***const T&/ const T\**** 时，结果会有一点变化，但仍符合上述推导规则，如下伪代码所示：

``` C++ 伪代码

template<typename T>     
void f(const T& param);        // 函数模板中参数使用的是个引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // 此时T的类型为int 形参param的类型是const int&

f(cx);               // 此时T的类型是int 形参param的类型是const int&

f(rx)      // 此时T的类型是int(由上述规则先排除引用部分) 形参param的类型是const int&

```

此时调用该模板函数时，若传入的参数本身就带有const则此时的const将被认定为模板形参中的const因此在推导形参T的类型时将不再考虑const。

# 3. 情况2：ParamType是个万能引用

对于持有万能引用形参的模板而言，规则就变得不那么明显了。此类形参的声明方式类似右值引用(即在模板中定义的形参写作 ***T&&***)，此时在调用传参时会根据参数是左值/右值而有所不同，具体细节参见[[6 右值引用,移动语义和完美转发#3. 区分万有引用和右值引用|万有引用/右值引用]]，此处给出基本规则：

- 若***expr***是个左值则 ***T*** 和 ***ParamType*** 都会被推导为左值引用。这样的推导比较特别：首先它比较反直觉，在模板声明的形参是右值引用的语法形式但推导结果却是左值引用。其次，这也是模板推导中唯一会把类型***T***推导为引用的情形。
- 若***expr***是个右值，则按照正常直觉推导即：按照**情况1**的规则推导。

如下伪代码示例所示：

``` C++ 伪代码

template<typename T>     
void f(const T&& param);        // 函数模板中参数使用的是个万能引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // x是左值因此此时T的类型为int& 形参param的类型是int&

f(cx);               // cx是左值因此此时T的类型是const int& 形参param的类型是const int&

f(rx)      // rx是左值因此此时T的类型是const int& 形参param的类型是const int&

f(27);     // 27是右值因此此时T的类型是int 形参param的类型是int&&

```

# 4. 情况3：ParamType即非指针也非引用

当***ParamType***既不是指针也不是引用时，我们通过值传递的方式处理，这意味着无论传递什么***param***都会成为它的一份拷贝——一个完整的新对象。这种情况也是我们使用最多的情形，型别(类型)推导会这样运作：

- 若***expr***的类型是一个引用则忽略引用部分。
- 若忽略引用部分后***expr***仍被const/volatile()修饰，则也忽略const/volatile。

实际上我们使用这种非指针非引用的值传递模板的情况最为普遍，接下来我们将从三种场景的情景分别讨论以帮助我们更加直观的理解。

## 4.1 普通类型实参

所谓普通类型实参指的是调用模板函数时传入的参数为一个普通的常见数据类型（结构体，类，基础类型以及其引用指针等），如下示例所示：

``` C++ 伪代码

template<typename T>     
void f(T param);        // 函数模板中参数既非指针也非引用 param为形参名

int x = 27;              // x的类型是int
const int cx = x;        // cx的类型是 const int
const int& rx = x;       // rx是x的型别(类型)为const int的引用(别名)

f(x);                // 此时T的类型为int 形参param的类型也是int
f(cx);               // 此时T的类型为int 形参param的类型也是int
f(rx)      // 此时T的类型为int 形参param的类型也是int

```

这里你可能会犯嘀咕了，既然***cx***为***const int***类型，***rx***为 ***const int***& 类型，那为什么在调用模板函数时形参***param***却是***int***型呢？其实这也可以理解，因为类型***T***的声明是一个值传递也就是说实际传递到函数中的参数只是***cx/rx***的一个副本(值传递会创建一个临时变量)。而按照***ParamType***既不是指针也不是引用时的推导规则，推导过程会忽略引用以及***const***修饰，因此真正传递给模板函数的那个临时变量***param***应该是***int***型的，尽管***cx***为***const int*** 而 ***rx*** 为 ***const int*** &。

我们要认识到只有在传值给形参时才会忽略***const***（和***volatile***）这一点很重要，回顾[[条款1： 理解模板型别推导#2. 情况1：ParamType是个指针或引用，但不是万能引用| 形参是个普通引用]]的情况，此时推导过程中***const***是会被保留的。

此外还有一种更为具有迷惑性的情况，如下伪代码所示：

``` C++ 伪代码

template<typename T>
void f(T param);                //仍然以值传递的方式处理param

const char* const ptr =         //ptr是一个常量指针，指向常量对象 
    "Fun with pointers";

f(ptr);    // 此时T的类型为const char* 形参param的类型也是const char*

```

这个示例的迷惑性在于***ptr***的类型定义中有两个***const***修饰，要理解最终的结果首先我们要对***const char\* const***类型进行分析。前面的***const*** 修饰的是 ***char\**** 意思是这个字符串的内容是不可被修改(***const***)的，而后面的***const***修饰的是指针***ptr***意味着这个指针是不可以被修改(***const***)的(也就是说***ptr***是不可以执行其他地址的甚至不可以将其复制为***nullptr***)。当将ptr作为参数传入模板函数时，按照[[条款1： 理解模板型别推导#4. 情况3：ParamType即非指针也非引用|值类型的推导过程]]：1. ***ptr***不是一个引用(注意条款里说的是引用并不包含指针)因此一步不需要考虑。2. ***ptr***有被***const***修饰，这个***const***修饰的是***ptr***本身而非***ptr***指向内存块中的数据(也就是后面一个***const***)。因此这个***const***会被忽略从而得出***T***及***param***的类型应该是***const char*** *。

## 4.2 数组实参

上述情况是使用值传递模板最常见的主流情况，除此之外还有一些边缘情况值得了解。数组就是一个比较特殊的参数类型，有时候他们看起来和指针可以互换，这就对数组类型参数的型别(类型)推导具有很强的迷惑性。如下示例代码所示：

``` C++ 伪代码

const char name[] = "J. P. Briggs"; // name的类型是const char[13]
const char* ptrToName = name; // 上文提到的数组与指针互换(此时数组退化成了指针)

template<typename T>
void f(T param);                //仍然以值传递的方式处理param

f(name);  // 实际上name是个const char[13]类型的数组，但T的型别(类型)会被推导成const char*

```

初步看来可能感觉很费解，但回到C++以数组作为函数参数本身来看，又会发现其实这样的型别推定是合理的。回顾下，假如我们在C++中以一个数组作为参数定义时我们该如何调用呢？

``` C++ 伪代码

void myFunc(int param[]);     // 用数组作为参数

int value[] = {1,2,3,4,5};    // 实际使用的参数数组

myFuc(value); // 实际上现在传入的参数是指向该数组的指针而并非数组本身的内存块

```

看到这里我们仿佛也明白了对于数组实参会被推导成相应类型的指针也是合理的。

更为复杂的问题来了， 尽管函数无法声明真正的数组类型的形参，但我们却能够将形参声明成数组的引用！当我们将形参的类型稍作修改，当我们再次传入数组时则意味着实参为该数组的引用，如下示例代码所示：

``` C++伪代码

const char name[] = "J. P. Briggs"; // name的类型是const char[13]

template<typename T>
void f(T& param);                // 以引用传递的方式处理param

f(name);  // 此时name是个const char[13]类型的数组，T的型别(类型)也会被推导成const char[13]，而实际传入函数的参数param则为const char (&)[13]

```

我们知道模板的推导过程在编辑阶段进行，因此利用声明数组引用这一特点我们可以创建一个模板用来推导出数组中含有元素的个数，如下示例代码所示：

``` C++ 伪代码

// 以编译器常量形式返回数组尺寸，在函数的形参定义中并为给数组其名字(变量名)，
// 这是因为我们只关心其包含的元素个数变量名根本不会被使用，当然你也可以写上一个形参变量名。
template<typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept   
{
	return N;
}

```

将函数声明为[[条款15：只要有可能使用constexpr就使用它|constexpr]]，能够使得其返回值在编译期就可用。从就可以在生命一个数组时指定其尺寸与另一数组相同，而后者的尺寸则从花括号初始化式中计算得出，如下伪代码所示：

``` C++ 伪代码

int keyVals[] = {1,3,7,9,11,22,35}; // keyVals由花括号初始化其中包含7个元素
int mappedVals[arraySize(keyVals)]; // 在编译期间就可以通过模板函数arraySize计算出mappedVals也有7个元素

```

上述模板函数中之所以将***arraySize***声明为[[条款14：只要函数与不会抛出异常就为其加上noexcept声明|noexcept]]为的是帮助编译器生成更好的目标码，我们将在后续[[条款14：只要函数与不会抛出异常就为其加上noexcept声明|条款14]]中详细讨论。

## 4.3 函数实参

在C++中与数组类似，函数型别(类型)也经常退化(被认为)成函数指针，因此对于[[条款1： 理解模板型别推导#4.2 数组实参|数组实参]]中的推导规则也都适用于函数实参。如下示例伪代码所示：

``` C++ 伪代码

void someFuc(int, double); // someFuc是一个函数声明，其类型为： void(int, double)

template<typename T>
void f1(T param);                //仍然以值传递的方式处理param

template<typename T>
void f2(T& param);                // 以引用传递的方式处理param

f1(someFuc);    // param被推导为函数指针，其型别类型是 void(*)(int, double)

f2(someFuc);   // param被推倒为函数引用，其型别类型是 viud(&)(int, double)

```

关于模板型别类型推导规则基本就是这些，在工作和使用时可能你会忘记某些推导细节或者向直接从编译器得出其推导出的型别类型究竟是什么？那么请翻阅[[条款4：掌握查看型别推导结果的方法]]，在此条款中我们将详细讨论如何忽悠编译器为你做这件事。

# 5. 要点速记

- 在模板型别(类型)推导过程中，具有引用型别(类型)的实参会被当成非引用类型来出来，也就是说其运用行会被忽略。
- 对万能引用形参进行推导时，左值实参会进行特殊处理。
- 对于按值传递的形参进行推导时，会忽略修饰实参的const/volatile。
- 在模板型别推导过程中，数组，函数类型的实参会被退化成为其对应的指针类型，除非他们被用来初始化引用(形参是值传递类型时会退化成指针，形成为引用时仍然保持其原本数组，函数类型)
