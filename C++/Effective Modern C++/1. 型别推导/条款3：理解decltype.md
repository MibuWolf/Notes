---
tags:
  - cplusplus decltype
---

# 1. 初识decltype

## 1.1 概述

***decltype***是declare type(声明类型)的缩写，是C++11新增的一个关键字，它与***auto***的功能都一样，都用来在编译期间进行自动型别/类型推导。那么既然已经有了***auto*** 关键字，为什么还需要 ***decltype*** 关键字呢？这是因为 ***auto*** 并不适用于所有的自动类型推导场景，在某些特殊情况下 ***auto*** 用起来非常不方便，甚至压根无法使用，所以 ***decltype*** 关键字也被引入到 C++11 中。

## 1.2 基本概念

***decltype*** 的基本用法如下：

``` C++ 伪代码

decltype(expression) // 其中expression为任意表达式，该语句的含义是返回expression的类型

int a = 0;
decltype(a) b = 1; // b会被推导为int型
decltype(1.234f) c = 1.0f; // c会被推导为float型
decltype(c + 100) d = 2.345f; // d会被推导为float型

```

有上述几个示例，可以看到的是 ***decltype*** 的作用是推导出表达式的类型。

## 1.3 型别/类型推导规则

既然 ***decltype*** 的作用也是进行型别/类型推导，这也就意味着它也有自己的型别/类型推导规则，具体来说型别推导规则如下：

- 如果表达式 ***expression*** 参数是不带括号()的简单标识符，或者是某个类的成员变量，那么 ***decltype(expression)*** 就是表达式***expression*** 的类型。如果并不存在 ***expression*** 这样的实体对象，或者 ***expression*** 描述的是一组经过重载(overloaded)的函数名(此时返回值类型可能有多个)，则会触发编译报错。
- 如果表达式 ***expression*** 是一个对函数或者重载运算符函数的调用，那么 ***decltype(expression)*** 表示的是函数的返回值类型，这里需要注意因为括号()比较特殊，因此此处所说的运算符重载不包括对括号()的重载。
- 如果表达式 ***expression*** 是一个右值那么 ***decltype(expression)*** 表示的是 ***expression*** 的类型。如果表达式 ***expression*** 是一个左值，***decltype(expression)*** 表示的是 ***expression*** 的左值引用类型。
- 如果表达式 ***expression*** 是一个被括号()修饰的表达式，应将()修正的***expression*** 整体作为一个表达式看待，而非简单标识符或者某个类的成员变量。此时整个被括号()修饰的表达式会被看作成一个左值，也就是说此时 ***decltype(expression)*** 表示的是 ***expression*** 的左值引用类型。

根据上述规则，我们来分析下面的代码示例：

``` C++ 伪代码

int var; 
const int&& fx(); 
struct A { double x; }; 
const A* a = new A();
int n = 0, m = 0;

decltype(var); // 使用推导规则一，var是一个不带括号的简单标识符，因此推导出的类型为var本身的类型即： int 
decltype(a->x); // 使用推导规则一，a->x是一个类的成员变量，因此推导出的类型为a->x本身的类型即： double 
decltype(fx()); // 适用推导规则二，fx()为一个函数调用因此其类型为函数返回值类型即：const int&&
decltype(m+n); // m+n表达式是两个int型数据相加的结果不能被赋值，因此是个右值，此时根据推导规则三得出其类型为： int
decltype(m=m+n); // m = m + n 表达式的结果是将m+n的结果赋给m，主体是m故可以继续给其赋值，因此该表达式是个左值表达式，根据推导规则三得出其类型为：int&
decltype((a->x)); // 此时表达式a->x是被括号()括起来的，因此不能将其看作是类的成员变量，而是将其看作一个整体。 根据推导规则四得出其类型为： double&

```

## 1.4 decltype vs auto

也许你会有这样的疑问，***decltype***与***auto***的功能都一样，都用来在编译期间进行自动型别/类型推导。那么既然已经有了***auto*** 关键字，为什么还需要 ***decltype*** 关键字呢？那是因为两者的推导规则不同，使用方式和适用场景不同，甚至有些情况下只能使用 ***decltype*** 关键字。在下文中我们将详细对比两者的区别和适用场景。

### 1.4.1 语法格式的区别

虽然***decltype***和***auto***都是C++11新增的用于型别/类型推导的关键字，但两者则用法和语法格式有着明显不同：

``` C++ 伪代码

auto varname = value;  //auto的语法格式  
decltype(exp) varname [= value];  //decltype的语法格式

```

其中，***varname*** 表示变量名，***value*** 表示赋给变量的值，***exp*** 表示一个表达式，方括号 ***[ ]*** 表示可有可无。也就是说：***auto*** 和 ***decltype*** 都会自动推导出变量 ***varname*** 的类型：

- ***auto*** 根据 `=` 右边的初始值 ***value*** 推导出变量的类型；
- ***decltype*** 根据 ***exp*** 表达式推导出变量的类型，跟 `=` 右边的 ***value*** 没有关系。

也就是说，***auto*** 要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 ***decltype*** 不要求，初始化与否都不影响变量的类型。因为 ***auto*** 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。  
  
***auto*** 将变量的类型和初始值绑定在一起，而 ***decltype*** 将变量的类型和初始值分开；虽然 ***auto*** 的书写更加简洁，但 ***decltype*** 的使用更加灵活。

### 1.4.2 对CV限定符的处理不同

所谓CV限定符是 ***const*** 和 ***volatile*** 关键字的统称：

- ***const*** 关键字用来表示数据是只读的，也就是不能被修改；
- ***volatile*** 和 ***const*** 是相反的，它用来表示数据是可变的、易变的，目的是不让 ***CPU*** 将数据缓存到寄存器，而是从原始的内存中读取。

由于[[条款2：理解auto型别推导|auot型别推导规则]]与[[条款3：理解decltype#1.3 型别/类型推导规则|decltype型别推导规则]]的不同，这就导致在推导变量类型时，***auto*** 和 ***decltype*** 对 CV 限制符的处理是不一样的。***decltype*** 会保留 CV 限定符，而 ***auto*** 有可能会去掉 CV 限定符。

### 1.4.3 对引用的处理不同

当表达式的类型为引用时，***auto*** 和 ***decltype*** 的推导规则也不一样；***decltype*** 会保留引用类型，而 ***auto*** 会抛弃引用类型，直接推导出它的原始类型。

***auto*** 虽然在书写格式上比 ***decltype*** 简单，但是它的推导规则复杂，有时候会改变表达式的原始类型；而 ***decltype*** 比较纯粹，它一般会坚持保留原始表达式的任何类型，让推导的结果更加原汁原味，但是 ***decltype*** 总是显得比较麻烦，尤其是当表达式比较复杂时。因此虽然***auto*** ，***decltype*** 两个关键字都用来做型别/类型推导，但其适用环境和推导规则不同，我们应根据需求选用。

# 2. 理解decltype

