---
tags:
  - cplusplus modern-cplusplus typedef enum
---

# 1. 概述

一般而言，在C++中如果在一对大括号中声明一个名字，则该名字的可见性就被限定在大括号的作用域范围内。但此规则却不适用于C++98风格的枚举型别中定义的枚举量。在C++98中定义的枚举，其枚举值/枚举量的作用域并非仅在定义该枚举量的大括号之内，其作用域范围与枚举定义的作用域范围相同：

``` C++

enum Color {red, green, blue};   // C++98风格的枚举定义
	// 此时的red green blue的作用域范围并不局限在大括号范围内
	// 此时red green blue的作用域与Color的作用域范围相同

auto red = false; // 编译错误，此时red已经在枚举Color中定义了
		  // 也就是说枚举值/枚举量read的作用域是跟Color相同的

```

这种枚举量的名字泄露到枚举型别/类型所在作用域的这一特性，在C++官方术语中被称为：不限范围的(_unscoped_)枚举型别。与之对应的在C++11中的限定作用域的(_scoped_)枚举型别，却不会以这样的方式泄露名字：

``` C++

enum class Color {red, green, blue}; // C++11的限定作用域枚举型别定义  此时 red green blue的作用域被限制在大括号范围之内

auto red = false;  // 没有问题, 在当前范围内无其他 "red"
Color c = red; // 错误 在当前范围内并无"red"的枚举量
Color c1 = Color::red; // 没有问题
auto c2 = Color::blue; // 同样没有问题 还符合优先使用auto的条款

```

由于限定作用域的枚举类型是通过`enum class`声明的，所以有时他们也被称为枚举类。

# 2. 限定作用域枚举的好处

## 2.1 限定作用域枚举的优势

限定作用域的枚举类型带来的名字空间污染降低，已经是"优先选用限定作用域枚举"的充分理由。然而除此之外，限定作用域枚举还有一个更为压倒性的优势：它的枚举量是更强型别(_strongly typed_)的。这是什么意思呢？对于不限定作用域枚举中的枚举值/枚举量，它是可以隐式转换到整型等其他类型的，但限定作用域枚举的枚举值/枚举量是不会进行隐式型别转换的。

``` C++

enum Color {red, green, blue};  // 不限定作用域枚举  此时枚举值
		                       // 是可以做隐式型别转换的

// 该函数的作用是返回类型为std::size_t的变量x的 质因数
std::vector<std::size_t> primeFactors(std::size_t x); 

Color c = red; // 不限定作用域枚举 因此 red枚举值在此可见

if(c < 14.5) // 将Color枚举类型的c与double型别的14.5进行比较(!)
{
	auto factors = primeFactors(c); // Color枚举类型的c隐式
								   // 转换成了std::size_t
}

```

这种自动的隐式的型别转换，使得代码变得诡异怪诞(为什么枚举类型可以与`double`进行比较？对枚举类型求质因数有何意义？)。而我们仅需在`enum`之后加上`class`(使用限定作用域枚举)后，整个语义一下子就变得完全不同了：

``` C++

enum Color {red, green, blue};  // 限定作用域枚举  此时枚举值
		                       // 是不会做隐式型别转换的

// 该函数的作用是返回类型为std::size_t的变量x的 质因数
std::vector<std::size_t> primeFactors(std::size_t x); 

Color c = Color::red; // 限定作用域枚举 

if(c < 14.5) // 编译错误 不能将Color类型与double进行比较
{
	auto factors = primeFactors(c); // 编译错误 primeFactors                   // 不接受Color类型参数 函数参数为std::size_t
}

```

当使用限定作用域枚举定义`Color`，而我们又真的想要将其转换成其他型别时，我们需要显示的调用强制型别转换：

``` C++

...

if(static_cast<double>(c) < 14.5) // 不自然的代码，但合法
{
	// 合法性存疑，但能够通过编译
	auto factors = primeFactors(static_cast<std::size_t>(c));
}

...

```

## 2.2 关于枚举的前置声明

这里还有一个误解：有些人可能认为限定作用域范围的枚举类是可以前置声明的，而非限定作用域范围的枚举则是不支持前置声明的，实际上这是一种误导。

在C++中，一切枚举型别都会由编译器来选择一个整数型别作为其底层型别，为了节约内存，编译器通常会为枚举型别选用足够表示枚举值/枚举量的最小底层型别。例如，对于上文示例中的`enum Color { red, green, blue };`编译器会选用`char`作为其底层型别，因为只有三个值需要表示。而对于 `enum Status { good = 0, failed = 1, incomplete = 100, corrupt = 200, indeterminate = 0xFFFFFFFF };`编译器则可能需用整型作为其底层型别，这是因为其枚举值范围达到32位。



# 3. 不限作用域枚举的好处



# 4. 要点速记

