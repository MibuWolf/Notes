---
tags:
  - cplusplus modern-cplusplus typedef enum
---

# 1. 概述

一般而言，在C++中如果在一对大括号中声明一个名字，则该名字的可见性就被限定在大括号的作用域范围内。但此规则却不适用于C++98风格的枚举型别中定义的枚举量。在C++98中定义的枚举，其枚举值/枚举量的作用域并非仅在定义该枚举量的大括号之内，其作用域范围与枚举定义的作用域范围相同：

``` C++

enum Color {red, green, blue};   // C++98风格的枚举定义
	// 此时的red green blue的作用域范围并不局限在大括号范围内
	// 此时red green blue的作用域与Color的作用域范围相同

auto red = false; // 编译错误，此时red已经在枚举Color中定义了
		  // 也就是说枚举值/枚举量read的作用域是跟Color相同的

```

这种枚举量的名字泄露到枚举型别/类型所在作用域的这一特性，在C++官方术语中被称为：不限范围的(_unscoped_)枚举型别。与之对应的在C++11中的限定作用域的(_scoped_)枚举型别，却不会以这样的方式泄露名字：

``` C++

enum class Color {red, green, blue}; // C++11的限定作用域枚举型别定义  此时 red green blue的作用域被限制在大括号范围之内

auto red = false;  // 没有问题, 在当前范围内无其他 "red"
Color c = red; // 错误 在当前范围内并无"red"的枚举量
Color c1 = Color::red; // 没有问题
auto c2 = Color::blue; // 同样没有问题 还符合优先使用auto的条款

```

由于限定作用域的枚举类型是通过`enum class`声明的，所以有时他们也被称为枚举类。

# 2. 限定作用域枚举的好处



# 3. 不限作用域枚举的好处



# 4. 要点速记

