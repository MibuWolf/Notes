---
tags:
  - cplusplus modern-cplusplus typedef enum
---

# 1. 概述

一般而言，在C++中如果在一对大括号中声明一个名字，则该名字的可见性就被限定在大括号的作用域范围内。但此规则却不适用于C++98风格的枚举型别中定义的枚举量。在C++98中定义的枚举，其枚举值/枚举量的作用域并非仅在定义该枚举量的大括号之内，其作用域范围与枚举定义的作用域范围相同：

``` C++

enum Color {red, green, blue};   // C++98风格的枚举定义
	// 此时的red green blue的作用域范围并不局限在大括号范围内
	// 此时red green blue的作用域与Color的作用域范围相同

auto red = false; // 编译错误，此时red已经在枚举Color中定义了
		  // 也就是说枚举值/枚举量read的作用域是跟Color相同的

```

这种枚举量的名字泄露到枚举型别/类型所在作用域的这一特性，在C++官方术语中被称为：不限范围的(_unscoped_)枚举型别。与之对应的在C++11中的限定作用域的(_scoped_)枚举型别，却不会以这样的方式泄露名字：

``` C++

enum class Color {red, green, blue}; // C++11的限定作用域枚举型别定义  此时 red green blue的作用域被限制在大括号范围之内

auto red = false;  // 没有问题, 在当前范围内无其他 "red"
Color c = red; // 错误 在当前范围内并无"red"的枚举量
Color c1 = Color::red; // 没有问题
auto c2 = Color::blue; // 同样没有问题 还符合优先使用auto的条款

```

由于限定作用域的枚举类型是通过`enum class`声明的，所以有时他们也被称为枚举类。

# 2. 限定作用域枚举的好处

## 2.1 限定作用域枚举的优势

限定作用域的枚举类型带来的名字空间污染降低，已经是"优先选用限定作用域枚举"的充分理由。然而除此之外，限定作用域枚举还有一个更为压倒性的优势：它的枚举量是更强型别(_strongly typed_)的。这是什么意思呢？对于不限定作用域枚举中的枚举值/枚举量，它是可以隐式转换到整型等其他类型的，但限定作用域枚举的枚举值/枚举量是不会进行隐式型别转换的。

``` C++

enum Color {red, green, blue};  // 不限定作用域枚举  此时枚举值
		                       // 是可以做隐式型别转换的

// 该函数的作用是返回类型为std::size_t的变量x的 质因数
std::vector<std::size_t> primeFactors(std::size_t x); 

Color c = red; // 不限定作用域枚举 因此 red枚举值在此可见

if(c < 14.5) // 将Color枚举类型的c与double型别的14.5进行比较(!)
{
	auto factors = primeFactors(c); // Color枚举类型的c隐式
								   // 转换成了std::size_t
}

```

这种自动的隐式的型别转换，使得代码变得诡异怪诞(为什么枚举类型可以与`double`进行比较？对枚举类型求质因数有何意义？)。而我们仅需在`enum`之后加上`class`(使用限定作用域枚举)后，整个语义一下子就变得完全不同了：

``` C++

enum Color {red, green, blue};  // 限定作用域枚举  此时枚举值
		                       // 是不会做隐式型别转换的

// 该函数的作用是返回类型为std::size_t的变量x的 质因数
std::vector<std::size_t> primeFactors(std::size_t x); 

Color c = Color::red; // 限定作用域枚举 

if(c < 14.5) // 编译错误 不能将Color类型与double进行比较
{
	auto factors = primeFactors(c); // 编译错误 primeFactors                   // 不接受Color类型参数 函数参数为std::size_t
}

```

当使用限定作用域枚举定义`Color`，而我们又真的想要将其转换成其他型别时，我们需要显示的调用强制型别转换：

``` C++

...

if(static_cast<double>(c) < 14.5) // 不自然的代码，但合法
{
	// 合法性存疑，但能够通过编译
	auto factors = primeFactors(static_cast<std::size_t>(c));
}

...

```

## 2.2 关于枚举的前置声明

这里还有一个误解：有些人可能认为限定作用域范围的枚举类是可以前置声明的，而非限定作用域范围的枚举则是不支持前置声明的，实际上这是一种误导。

在C++中，一切枚举型别都会由编译器来选择一个整数型别作为其底层型别，为了节约内存，编译器通常会为枚举型别选用足够表示枚举值/枚举量的最小底层型别。例如，对于上文示例中的`enum Color { red, green, blue };`编译器会选用`char`作为其底层型别，因为只有三个值需要表示。而对于 `enum Status { good = 0, failed = 1, incomplete = 100, corrupt = 200, indeterminate = 0xFFFFFFFF };`编译器则可能需用整型作为其底层型别，这是因为其枚举值范围达到32位。

既然编译器选用什么型别走位枚举的底层型别是由枚举值/枚举量决定的，那么在C++98中就只提供了对枚举型别定义(即：列出所有枚举量)的支持，枚举型别声明则不被允许。在C++98中，这种对枚举前置声明能力的缺失也会带来一些弊端：人为的增加了依赖性，由于不支持枚举前置声明，在代码中就只能包含对枚举的定义，这也就意味着一旦需要对枚举值进行扩充或缩减就需要对整个依赖该枚举的项目进行编译。这一弊端，在C++11中则可以利用枚举型别提供的前置声明的能力破除解决：

``` C++

enum class Status; // Status枚举的前置声明

void ContinueProcessing(Status s); // 取用前置声明的枚举型别
     // 具体枚举Status的定义可以在其他文件中实现，若扩充/缩减
     // 该枚举的枚举值，只要不影响该函数中用到的枚举值则无需
     // 重新编译该函数的代码

```

那么问题来了，为什么C++11中的枚举型别就可以进行前置声明，而C++98中的不行呢？其实这是因为：限定作用域枚举型别的底层型别是已知的，而对于不限作用域枚举型别，我们也是可以指定其底层型别的。

在C++11中，对于限定作用域枚举型别而言，默认的其底层型别为`int`型，如果默认型别不符合我们预期，我们可以推翻它：

``` C++

enum class Status;  // 默认底层型别为int

enum class Status : std:uint32_t; // 默认底层型型别为int不符合
			   // 我的预期，可以将其底层型别定义为std:uint32_t

```

正是由于通过此方式可以让编译器在其定义之前就知道其底层型别类型从而确定其占用内存，也才使得在C++11中对枚举的前置声明变得可行。同样的，在C++11中，通过显示的指定不限作用域枚举型别的底层型别类型后，其也将变得能够进行前置声明了：

``` C++

enum Color : std:uint8_t; // 不限范围的枚举型别的前置声明
						 // 指定其底层型别是 std:uint8_t
 ... 

// 枚举Color的定义可以在后续 甚至其他文件中进行

```

# 3. 不限作用域枚举的好处

前文中讨论了很多关于限定作用域枚举的优势及好处，事实上至少在一种情况下不限作用域枚举是存在优势的，那就是当在使用C++11中的元组 (`std::tuple`)需要获取其中各个域中的信息时：

``` C++

using UserInfo = 
std::tuple<std::string,  // 名字
           std::string,  // 电子邮件
           std::size_t>  // 声望值

```

在使用该容器存储数据时，若想获取电子邮件地址信息则可通过以下方式：

``` C++

UserInfo uInfo;
...

auto value = std::get<1>(uInfo); // 获取容器中第1个
                // 位置(从0开始)中存储的数据即：电子邮件

```

虽然这样的写法可以获取到正确的数据信息，但是作为程序员我们很难记得数字 0,1,2,.... 与 名字 电子邮件 声望值 .... 之前的一一对应关系，并且这样的代码也很容易让后续的维护者摸不着头脑。

# 4. 要点速记

