---
tags:
  - cplusplus modern-cplusplus
---

# 1. "眼花缭乱"的初始化语法

在C++11中对象初始化有多种方式：使用`()`或者`{}`或者使用`=`亦或者使用`={}`。如下示例代码所示：

``` C++

int x(0);           // 在小括号()中初始化
int y = 0;          // 使用等号=初始化，此处是初始化并非赋值
int z{0};           // 使用大括号{}初始化
int z1 = {0};       // 使用等号=和大括号{}初始化 此方式与直接使用大括号{}初始化
              // 的方式本质上相同，因为C++通常会把它和只有大括号{}的语法同样处理

```

众多的初始化方式往往会让人"眼花缭乱"，当我们正真想要初始化对象时，对于选用哪种方式对其进行初始化又往往会 "无所适从"，因为我们常常无法精确的把握每一种赋值方式的精确含义。例如，当使用等号 `=` 时究竟调用的是复制构造函数还是赋值运算符？两者在自定义类中通常是两个不同的函数，如下示例代码所示：

``` C++

Widget w1;  // Widget为自定义类，此时会通过调用Widget的默认构造函数完成对w1的初始化

Widget w2 = w1; // 此处最容易让人疑惑，其调用的究竟是复制构造函数还是赋值运算符？
                // 实际上此处并非赋值，而是对w2的初始化，也就是说此处调用的是复制
                // 构造函数
w1 = w2;        // 此处才是正真的赋值，调用的是赋值运算符

```

此外，在C++11中的 `{}` 初始化方式出来前，其他众多的初始化语法仍然没有办法来表达某些特定想要表达的初始化亦或者存在各种使用限制。例如：1. 使用 `STL`定义一个容器时，就无法指定该容器中初始化一组指定的数据集合(eg: `std::vector<int> v; `无法在初始化时就指定`v`中包含数据`{1，2，3}`)。2. `()`无法用来为非静态成员变量指定默认初始化值。3. 不可复制对象(例如 `std::atomic` 类型的对象)不能使用 `=` 来进行初始化。

为了着手解决C++98众多初始化语法带来的困惑，也为了解决这些语法不能涵盖所有初始化场景的问题，C++11引入了统一初始化：单一的，至少从概念上可以用于一切场合的初始化。即：大括号(`{}`)形式的初始化，该方式解决了上述所有问题，如下示例代码所示：

``` C++

std::vector v{1,2,3};   // 用指定数据初始化vector容器

class Widget
{
...

private:

int x {0};  // 可以用大括号初始化非静态成员变量
int y = 0;  // 可以用等号初始化非静态成员变量
int z(0);   // error  不可以用小括号初始化非静态成员变量
}

std::atomic<int> ai1{0};  // 可以用大括号初始化不可复制对象
std::atomic<int> ai2(0);  // 可以用小括号初始化不可复制对象
std::atomic<int> ai3 = 0;  // 不可以用等号初始化不可复制对象

```

# 2. 大括号初始化的特性

C++11中新增的大括号(`{}`)形式的初始化的方式也有一些独特的特性和规则，我们将分别详细讨论。

## 2.1 禁止隐式窄化型别转换(narrowing conversion)

禁止隐式窄化型别转换(narrowing conversion)指的是：如果一个使用了花括号(`{}`)初始化的表达式，不能直接由所初始化对象的类型所表示，则可能导致编译失败。简单点来说，用花括号(`{}`)初始化的表达式必须是该对象类型，不支持经过隐式转换成该对象类型，如下示例所示：

``` C++

float x,y,z;

...

int sum1(x+y+z); // OK 用()初始化时会将float隐式转化成int
int sum2 = x+y+z; // OK 用=初始化时也会将float隐式转化成int
int sum3{x+y+z}; // Error {}不接受表达式的隐式类型转化

```

## 2.2 对于C++的令人苦恼的解析语法(most vexing parse)免疫

所谓对于C++的令人苦恼的解析语法(most vexing parse)免疫指的是：C++的规则会优先将代码解释成函数声明，这就会导致我们使用默认构造函数来初始化一个对象时，会被C++当作成一个函数声明。如下代码示例所示：

``` C++

Widget w1(10);  // 调用一个int参数为输入的构造函数
Widget w2(); // 想要用默认构造函数初始化w2，但实际上会被编译器理 // 解为一定了一个名为w2的函数，该函数没有输入参数，输出参数类型
// 为Widget。这就是令人苦恼的解析语法问题
widget w3{} // 正常以调用默认构造函数的方式初始化w3变量

```

## 2.3 对std::initializer_list的偏爱

