---
tags:
  - cplusplus modern-cplusplus
---

# 1. 概述

在C++11中对象初始化有多种方式：使用`()`或者`{}`或者使用`=`亦或者使用`={}`。如下示例代码所示：

``` C++

int x(0);           // 在小括号()中初始化
int y = 0;          // 使用等号=初始化，此处是初始化并非赋值
int z{0};           // 使用大括号{}初始化
int z1 = {0};       // 使用等号=和大括号{}初始化 此方式与直接使用大括号{}初始化
              // 的方式本质上相同，因为C++通常会把它和只有大括号{}的语法同样处理

```

众多的初始化方式往往会让人"眼花缭乱"，当我们正真想要初始化对象时，对于选用哪种方式对其进行初始化又往往会 "无所适从"，因为我们常常无法精确的把握每一种赋值方式的精确含义。例如，当使用等号 `=` 时究竟调用的是复制构造函数还是赋值运算符？两者在自定义类中通常是两个不同的函数，如下示例代码所示：

``` C++

Widget w1;  // Widget为自定义类，此时会通过调用Widget的默认构造函数完成对w1的初始化

Widget w2 = w1; // 此处最容易让人疑惑，其调用的究竟是复制构造函数还是赋值运算符？
                // 实际上此处并非赋值，而是对w2的初始化，也就是说此处调用的是复制
                // 构造函数
w1 = w2;        // 此处才是正真的赋值，调用的是赋值运算符

```

此外，在C++11中的 `{}` 初始化方式出来前，其他众多的初始化语法仍然没有办法来表达某些特定想要表达的初始化亦或者存在各种使用限制。例如：1. 使用 `STL`定义一个容器时，就无法指定该容器中初始化一组指定的数据集合(eg: `std::vector<int> v; `无法在初始化时就指定`v`中包含数据`{1，2，3}`)。2. `()`无法用来为非静态成员变量指定默认初始化值。3. 不可复制对象(例如 `std::atomic` 类型的对象)不能使用 `=` 来进行初始化。

为了着手解决C++98众多初始化语法带来的困惑，也为了解决这些语法不能涵盖所有初始化场景的问题，C++11引入了统一初始化：单一的，zhi



     