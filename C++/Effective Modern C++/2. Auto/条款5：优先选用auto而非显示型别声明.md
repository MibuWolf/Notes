---
tags:
  - cplusplus auto
---

# 1. 概述

在[[条款2：理解auto型别推导|条款2：理解auot型别推导]]中我们已经了解和讨论的`auto`的基本用法和其型别推导规则。本文我们将讨论使用`auto`带来的额外好处，以及我们推荐有限选用`auto`而非显示型别声明的原因。

# 2. 起码可以少打些字

使用`auto`的第一个也是最显而易见的好处就是：可以少打些字。如下代码示例：

``` C++

template<typename It>    // dwim（do what I wmen 做我想的函数）
void dwim(It b, It e)    // 应用范围是从b到e的所有元素，对其进行...任意操作
{
	while(b != e)
	{
		typename std::iterator_traits<It>::value_type
		currValue = *b;
		...
	}
}

```

使用`typename std::iterator_traits<It>::value_type`来表达迭代器所指涉到的元素类型写这么长的一个类型实在是毫无编码乐趣，此时使用`auto`则恰好可以将我们从这无聊的几十个字符长度的类型名中解脱出来；

``` C++

template<typename It>    // dwim（do what I wmen 做我想的函数）
void dwim(It b, It e)    // 应用范围是从b到e的所有元素，对其进行...任意操作
{
	while(b != e)
	{
		auto currValue = *b;   // 简单明了
		...
	 }
}

```

此外，我们知道使用`auto`声明的变量必须初始化，否则会导致编译错误。利用这一特点我们可以解决潜在的未初始化的风险。

一个简单的存在未初始化的风险的示例就是我们定义了一个变量但并未对其进行初始化，如下所示：

``` C++

int x;

```

如果我忘记初始化或在后续逻辑中对 `x` 赋值了，那么在使用它的时候它的值是不确定的。但严格来说，也不一定不确定也可能被初始化为 `0` 了，这取决于具体语境和环境。但总之，此时使用  `x`是存在未初始化风险的，这种风险倒不一定会引起报错或经过，但在后续运行时执行的某一刻突发一个莫名其妙的BUG将会使得问题更为复杂和难以排除。

因此使用`auto`声明的变量就很好的避免了这一潜在风险，因为如果玩