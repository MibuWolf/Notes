---
tags:
  - DesignPatterns
---

# 1. 概述

创建型模式也就是创建对象的时候所使用的设计模式。常见的创建型模式有：简单工厂，工厂方法，抽象工厂，生成器，原型和单例几种模式。本章我们将针对以上的几种模式进行讨论，并分析每一种模式的适用情境。

# 2. 三种工厂模式

在上文中我们提到简单工厂，工厂方法和抽象工厂三种设计模式。他们都是工厂类模式，那么这三种工厂模式有什么区别，他们又有什么优劣和各自的适用环境的，本节我们将分别详细地讨论这三种工厂模式以及它的基本结构和适用环境。

## 2.1 简单工厂模式

### 2.1.1 模式描述

在简单工厂模式中首先会为所有的产品提供一个基类，所有的产品都是该基类的派生类。工厂类则负责创建和实例化具体的产品。 这也就意味着在工厂类内部做判断，根据输入的数据创建相应的产品类型。比如说，在游戏当中会有很多不同的游戏对象：角色，怪物交互物等，当服务器用一个统一的数据结构来创建游戏中所有游戏对象时（例如，服务器使用同样一个的 Proto数据结构下发场景内所有游戏对象的数据），我们就可以使用一个简单工厂模式。在该工厂模式中工厂类接收服务器的proto数据，并在工厂类内部根据服务器下发的数据类型，分析创建实例化不同的产品对象。 这就是一个简单工厂模式的基本运作原理和使用方式。

### 2.1.2 角色组成

#### 产品接口/基类

产品的接口类/基类，提供了所有产品公用的方法供子类/派生类去继承实现。

#### 产品类

继承产品接口类，从而实现各式各样的产品类型。

#### 工厂类

定义创建和实例化产品的接口，并在工厂内部根据数据实例化具体的不同类型的产品。

### 2.1.3 UML图

![[计算机理论基础/设计模式/attachments/Pic_001.png]]

### 2.1.4 优缺点

#### 优点

简单工厂的优点：实现了对象创建和对象使用的分离，将对象创建交给专门的工厂类负责。工厂类可以根据传入的数据自主的决定创建和实例化哪种产品类型，用户完全无需关心应该创建哪个产品对象以及具体的产品/对象是如何实例化的。明确了各自的权责范围，有利于整个软件体系的结构化优化。

#### 缺点

简单工厂的缺点：扩展性较差，违反了开闭原则，每增加一种新的产品类型时不得不去修改工厂类。

## 2.2 工厂方法模式

正如上文中提到的那样，在使用简单工厂方法模式时，如果要增加或删除新的产品子类，那么就必须修改简单工厂类的内容，这明显违反了开闭原则。工厂方法模式，就是针对简单工厂模式的进一步解耦。其基本思路是提供一个工厂类的基类，将产品实例化过程分散在每个具体的工厂类当中，每一个具体的产品类由一个具体的工厂类进行生产和实例化。

### 2.2.1 模式描述

定义一个用来创建产品的工厂接口类，让他的子类决定具体实例化哪一种产品。将每一种具体产品的实例化与特定的工厂类绑定，由具体工厂类实例化具体产品，使得系统同时具备了弹性和扩展性，解决了简单工厂模式下的违反开闭原则的问题。

### 2.2.2 角色组成

#### 产品接口类

定义了所有产品共有的方法/内容，所有产品类都继承自该接口类。

#### 产品类

是继承自产品接口类的派生类，用于实现和定义特定的产品类型。

#### 工厂接口类

定义了创建和实例化产品的接口是所有工厂类的基类。

#### 工厂类

是工厂接口类的派生类，是用于具体实现和实例化某种特定的产品对象的工厂类。

### 2.2.3 UML图

![[计算机理论基础/设计模式/attachments/Pic_002.png]]

### 2.2.4 优缺点

#### 优点

- 解决了简单工厂模式违反开闭和原则的问题，具有很强的扩展性弹性和可维护性，扩展时只需增加一个新的工厂类即可增加一种新的产品类型。

- 使用了依赖倒置原则，使得客户并不需要知道所有的具体的工厂类，仅需依赖工厂基类即可。

#### 缺点

一个具体的产品对应一个工厂类，这就意味着每新增一个产品时，就需要新增一个工厂类与之对应。当产品的类型较多时，这无疑会导致系统中的类的数量增多，增加系统的复杂度增加系统的维护成本。

## 2.3 抽象工厂模式

虽然工厂方法模式解决了简单工厂模式关于扩展维护的问题，但抽象工厂模式本身也存在问题：随着产品种类的增多，代码就会变得庞大而复杂，抽象工厂模式就是为了解决这些问题而出现的。它和工厂方法模式的区别在于：简单工厂和工厂方法模式中的工厂类都只对应一个产品类（也就是说一个工厂内只生产特定的一种产品）。而抽象工厂模式中的工厂类，一个工厂是可以生产多个产品。

### 2.3.1 模式描述

提供一个抽象工厂类基类，该基类中提供一系列创建产品对象的接口，该基类无需真正创建产品类，产品的实例化由具体的工厂类负责创建。每个具体的工厂类负责实例化一个系列的产品。例如，可以将一个汽车工厂类定义为抽象工厂的基类，该基类提供创建小汽车，SUV，跑车等各种类型汽车的接口。宝马汽车工厂就是一个具体的工厂类，他负责生产宝马小汽车，宝马SUV，宝马跑车，一个系列的产品，这就是抽象工厂模式的基本概念。

### 2.3.2 角色组成

#### 产品族接口

相当于产品的基类，由该接口类可以派生出各种产品，相当于上面例子中的汽车基类。

#### 具体产品

继承子产品，族接口实现的具体的产品类，上面例子中的宝马，小汽车，宝马，SUV等。

#### 工厂接口

由用户直接使用的抽象工厂类的接口。

#### 具体工厂

继承字工厂接口实现某一系列的具体产品的工厂类。

### 2.3.3 UML图

![[计算机理论基础/设计模式/attachments/Pic_003.png]]

### 2.3.4 优缺点

#### 优点

- 一个具体工厂内可以创建多个产品与工厂方法模式相比，可以减少具体工厂类的数量。

- 允许用户使用抽象工厂类接口创建于一组相关的产品，而不需要知道产生的具体产品内容，这样就可以将用户和具体产品解耦。

- 易于更换和新增新的产品系列，只需修改或新增具体工厂类，就可以实现整个系列产品的替换。

#### 缺点

由于抽象工厂类是将一组产品定义到了一个工厂类当中，因此当需要新增或修改某一个产品类时，也需要迭代和修改抽象工厂类，所以它的扩展性比较差。

# 3. Builder模式（建造者模式）

前面提到的工厂模式适合用来创建和实例化简单结构的产品对象。但当我们需要实例化一个复杂的类以得到不同结构类型和不同的内部状态的对象时，仅仅使用工厂模式就不能满足这一需求。

## 3.1 适用性

回顾工厂模式中我们举的汽车工厂的例子：如果每一个汽车产品都可以直接简单实例化就可以生产出来，那么的确很适合使用工厂模式。但考虑现实的情况，每一辆车子的生产都需要安装引擎，装配轮胎，喷漆，安装座椅等步骤才能完成装配和生产。而每一个步骤在生产不同的汽车产品时所需要执行的操作又各不相同，此时再使用工厂模式就很难定制化，生产出不同类型的汽车产品。此时就需要一种新的创建型设计模式------Builder模式。

## 3.2 模式概述

建造者（Builder）模式的基本思路是：将创建产品的构建算法/构建过程与内容表示分离。所有产品的构建过程/算法是统一的，由所谓的导向器类进行生产构建过程的调用。而每个具体产品的生产步骤则由不同的生成器进行生产。最终实现一个由导向器控制装配步骤，不同生成器处理每个步骤中内容细节的产品生产过程。

## 3.3 角色组成

#### 生成器Director

生成器负责按照一定的算法或者具体的顺序调用建造者，并利用不同的建造者构建出不同的产品对象，生成器被用户直接持有。

#### 抽象建造者 Builder

抽象建造者提供一个建造者接口类或者是基类用于规范产品对象的构建过程中的步骤方法。

#### 具体建造者Builder

继承自抽象建造者为具体的产品提供不同的构建方法或过程。

#### 产品类

用户所希望构建的复杂对象，也是我们所要真正创建和实例化的对象。

## 3.4 UML图

![[计算机理论基础/设计模式/attachments/Pic_004.png]]

## 3.5 优缺点

#### 优点

建造者模式独立易扩展，符合开闭原则，具体建造者相互独立，方便扩展。

建造者模式可以更方便的控制细节，便于细节把控和风险评估。

该模式将产品的创建过程与产品内部细节解耦，使得使用相同的创建过程，可以创建出不同的产品对象。

#### 缺点

由于产品的生产过程完全由同一生成控制，这就要求产品必须有相同的创建流程，因此使用范围有限。

如果不同产品内部变化复杂，则会产生很多不同的建造类。

# 4. Prototype模式（原型模式）

前面几种设计模式中要创建或实例化产品，对象时必须定义和使用额外的工厂类或者建造者类。而在使用圆形模式实例化和创建产品时，则无需使用其他辅助类。

## 4.1 适用性

当我们要实例化的产品类是在运行时指定的，例如通过动态加载dll，在运行时动态创建 Dll库中的产品类。或者为了避免创建一个与产品类层次平行的工厂类，亦或是当系统需要创建许多相同或相似对象时，都可以考虑使用原型模式来实现。

## 4.2 模式概述

原型模式的基本思路是使用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

## 4.3 角色组

#### 原型基类/原型接口类

该类为所有原型类提供一个克隆自己的接口。

#### 原型类

继承原型基类，在该类中通过克隆自身实现创建和实例化一个新的对象。

#### 客户类

该类是用户方在运行时可以通过传入不同的原型类实例化出新的原型对象。

## 4.4 UML图

![[计算机理论基础/设计模式/attachments/Pic_005.png]]

## 4.5 优缺点

#### 优点

既对客户隐藏的实现细节又是代码简洁可读性高，易于维护。

可以简单方便的复制对象，有利于减少用户复制对象时产生的漏传，漏复制等低级错误。

#### 缺点

缺点就是利用拷贝实现新的对象实例化时要考虑深拷贝和浅拷贝的问题。

# 5. 单例模式

前面提到的几种创建型模式都是用来创建大量不同的产品对象的，但有些时候我们希望使用一个全局唯一的产品类对象，此时单例模式就是比较适合的方式。

## 5.1 适用性

当我们的某个类只希望有一个实例对象，并且用户可以方便的访问它时，可以考虑使用单例模式。

## 5.2 模式概述

单例模式的目的是保证一个类只有一个实例，并且为他提供一个全局可方便访问的点入口点。

## 5.3 角色组

#### Singleton

负责创建他自己的唯一实力，定义一个Instance操作，允许客户访问他的唯一实例。

## 5.4 优缺点

#### 优点

为特定类型对象提供唯一实例的受控访问，确保所有对象访问和使用的都是一个实例。

由于在系统内只存在一个该类型的对象，因此可以节约系统资源，避免了不必要的频繁创建销毁过程。

#### 缺点

由于单例为某特定对象提供唯一的受控者，因此该模式不适用于频繁变化的对象。

单例类的职责过重，在一定程度上违背了单一职责原则。

由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。