---
tags:
  - DesignPatterns
---

# 1. 概述

前面两章我们讨论了创建对象时使用的创建型模式以及类和对象组合的结构型模式。本章我们将要讨论的行为型模式，行为型设计模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。行为型模式是对不同的对象之间划分责任和算法的抽象化。

通过行为型模式可以更加清晰的划分类与对象的职责，并研究系统在运行时实例对象之间的交互。行为型模式分为类行为型模式和对象行为型模式两种：类行为型模式使用继承关系，在几个类之间分配行为，主要通过多态等方式来分配父类和子类的职责。对象行为型模式则使用对象的聚合关联关系来分配行为。

常见的行为型模式有：职责链模式(对象行为型模式)，命令模式(对象行为型模式)，解释器模式(类行为型模式)，迭代器模式(对象行为型模式)，中介者模式(对象行为型模式)，备忘录模式(对象行为型模式)，观察者模式(对象行为型模式)，状态模式(对象行为型模式)，策略模式(对象行为型模式)，模板方法模式(类行为型模式)和访问者模式(对象行为型模式)。本章我们将详细分析和理解每一种模式的职责和作用。

# 2. 责任链模式(ChainOfResponsibility)

## 2.1 背景与动机

在开发当中我们经常会遇到这样的情景，当我们触发一个事件，而又并不明确知道谁是最终接收和执行这个指令的对象，而我门又希望将提交请求的对象与可能处理这个请求的对象进行解耦，此时我们就可以考虑使用职责链模式。

一个最常见的例子是在做UI开发的时，对于一个多层复杂结构的界面。当鼠标点击界面时，点击事件会逐层向上传导，直到需要执行点击事件的那个按钮或控件执行具体的点击回调行为。 AS3中的事件冒泡机制就是一个具体的职责链模式实践。

## 2.2 定义与模式描述

职责链模式：为使多个对象都有机会处理同一请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个或几个对象处理它。

## 2.3 角色组成与参与者

责任链模式一般由以下几个角色组成：

#### Handler(处理事件的抽象类接口)

定义一个处理请求的抽象基类，包含抽象处理方法和一个转发给后继者的接口。

#### ConcreteHandler(具体事件处理类)

继承自抽象事件处理接口类，用于实现具体的事件处理，判断当前是否需要执行，以及是否需要将事件转发给后继者。

#### Client(客户类)

创建处理链并向处理链中发送事件，他并不关心处理细节以及事件的传递过程。

## 2.4 UML图与时序图

### 2.4.1 UML图

![[计算机理论基础/设计模式/attachments/Pic_006.png]]

### 2.4.2 时序图

![[计算机理论基础/设计模式/attachments/Pic_007.png]]

## 2.5 优缺点

### 优点

责任链模式最明显的优点是发送方和接收方的处理对象类之间完全解耦。

将每个处理对象封装成类，满足开闭原则。可以非常方便的添加处理对象，调整处理对象之间的顺序提高了灵活性和可维护性。

每个类只需要处理自己该处理的工作，并决定是否传递给下一任对象，责任分工明确，符合类的单一职责原则。

### 2.5.2 缺点

由于一条请求并没有明确的接收者，所以并不能保证它一定被处理或执行该请求，可能一直传递到链的末端，都得不到执行和处理。

责任链的建立要靠用户端来保证，增加了用户端的复杂性，如果用户使用不当则可能导致责任链形成循环调用等问题。

对于比较长的责任链请求的处理，可能涉及到多个处理对象，系统性能可能会受到一定影响，并且代码调试不太方便。

# 3. 命令(Command)模式

## 3.1 背景与动机

在日常工作中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，我们只需要在程序运行时指定具体的请求接收者即可，此时我们就可以使用命令模式来进行设计，使得请求的发送者和请求的接收者彼此解耦。

## 3.2 定义与模式描述

命令模式是将一个请求封装成一个对象，从而使我们可用不同的请求对对象进行参数化，对请求排队或记录请求、日志以及撤销请求操作给予支持。

## 3.3 角色组成与参与者

#### Command(抽象命令接口)

Command抽象命令接口用于声明执行操作的接口。

#### ConcreteCommand(具体命令类)

继承字抽象命令接口，调用接收者(Receiver)的相应操作，以实现一个具体的指令或命令。

#### Invoker(调用者)

命令的调用者或派发者。

#### Receiver(接收者)

某一命令或事件的具体执行者，他知道该如何执行和实施某一命令的具体操作，一般被具体命令内所持有用于真正执行具体的操作或行为，任何类都可能作为一个接收者。

## 3. 4UML图与时序图

### 3.4.1 UML图

![[计算机理论基础/设计模式/attachments/Pic_008.png]]
![[计算机理论基础/设计模式/attachments/Pic_009.png]]

### 3.4.2 时序图

![[计算机理论基础/设计模式/attachments/Pic_010.png]]
![[计算机理论基础/设计模式/attachments/Pic_011.png]]

## 3.5 优缺点

#### 优点

命令模式可以有效的降低系统耦合度。

可以非常快速简单的新增命令。

可以比较简单容易的设计和实现一个命令队列或命令组合。

可以简单方便的实现对命令的请求撤销重做等操作。

#### 缺点

使用命令模式可能会导致系统有过多的具体命令类，因为针对每一个命令都需要设计一个具体命令类，因此系统可能需要大量的具体命令类，这将降低系统的可维护性。

# 4. 解释器(Interpreter)模式

## 4.1 背景与动机

在软件开发中会遇到有些问题反复多次重复出现，而且有一定的相似性和规律性，如果把他们归纳成一种简单的语言，那么这些问题实例将是该语言中的一些句子，此时就可以利用编译原理中的解释器模式来解决这些问题。一个常见的事例是正则表达式，另一个常见的例子是在某些游戏项目中定义的XML配置技能的方式，XML技能配置也可以看作是一种自定义语言，并使用解释器来解释技能过程的事例。

## 4.2 定义与描述

解释器模式：给定一个语言，定义该语言文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

## 4.3 角色组成与参与者

#### 抽象表达式(Abstract Expression)

声明一个抽象的解释操作接口，这个接口为抽象语法树中所有节点的基类。

#### 终结符表达式(Terminal Expression)

是抽象表达式的派生类，用来实现文法中与结束符相关的操作，文法中的每一个结束符都有一个具体的终结表达式类与之对应。例如：对正则表达式进行解释时，一个回车字符可能表示一段正则表达式的终结，对回车字符的解释，就是一个终结符表达式。

#### 非终结符表达式(NoterminalExpression)

是抽象表达式类的派生类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。例如：对正则表达式中与或非符号的解释就是非终结符表达式。

#### 环境(Context)

环境角色通常包括每个解释器需要的数据或者公共功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些信息或功能。

#### 用户(Client)

用户的主要任务是将需要分析的句子或表达式转化成为使用解释器对象描述的抽象语法树，然后调用解释器的解释方法执行或解释整段句子或表达式。

## 4.4 UML图

### 4.4.1 UML图：

![[计算机理论基础/设计模式/attachments/Pic_012.png]]

## 4.5 优缺点

#### 优点

解释器最大的优点是具有灵活性和扩展性，利用现有的解释器可以像讯指一样书写并解释各种逻辑。

增加了新的解释表达式的方法。

易于实现简单的文法。

#### 缺点

缺点之一就是可以利用解释器的场景比较少。

对于复杂的文法比较难以维护。

复杂的解释器可能会导致代码和类的膨胀。

# 5. 迭代器(Iteator)模式

## 5.1 背景与动机

在业务功能开发时，经常会遇到这样的情况：我们设计了一个聚合对象类，希望可以该类可以为外部提供一个遍历访问当前类中所有对象的方法，但我们又不希望暴露我们类的内部结构给外部使用。此时就可以使用迭代器模式为外部提供屏蔽内部结构的循环通历调用方式。

## 5.2 定义与描述

迭代器(Iterator)模式：提供一种方法，顺序访问一个聚合对象内的各个元素，而又不需要暴露该对象的内部表示。

## 5.3 角色组成与参与者

#### 迭代器(Iterator)

迭代器的接口类或基类，声明了遍历集合所需要的操作接口。

#### 具体迭代器(ConcreteIterator)

继承子迭代器接口实现具体的一种遍历集合的特定算法。(例如最常见的从前往后依次遍历)

#### 聚合接口类(Aggregate)

定义管理待遍历元素的聚合接口类，该接口类可以声明一个或多个方法来获取与集合兼容的不同迭代器。

#### 具体聚合类(ConcreteIterator)

继承自聚合接口类的一个具体聚合类实例。

#### 用户(Client)

用户一般是指：需要利用迭代器模式进行遍历的使用者。用户通过使用具体聚合类和具体迭代器类的配合使用完成对具体聚合类的内部数据的遍历。

**_注：可以通过妧类或特定针对Iterator暴露的接口完成迭代器对聚合类的内部访问，而聚合类可以并不提供公有的对外使用的遍历接口。_**

## 5.4 UML图

![[计算机理论基础/设计模式/attachments/Pic_013.png]]

## 5.5 优缺点

#### 优点

迭代器模式支持以不同的方式遍历同一个聚合对象。

迭代器简化了，聚合类的实现。

使用迭代器模式增加新的聚合类和迭代器类都很方便，无需修改原有代码。

#### 缺点

由于迭代器模式将存储数据和便利数据的职责分离新增的聚合类需要对应新增新的迭代系列，类的个数会成倍增加，这在一定程度上增加了系统的复杂性。

# 6. 中介者(Mediator)模式

## 6.1 背景与动机

在面向对象的系统设计中，我们经常会把行为分布在各个不同对象中，这种分布可能会导致对象之间有许多关联。虽然将一个完整的系统划分为许多行为对象有助于提高复用性，但是多个对象之间复杂的关系又会降低其复用的可能性。大量行为的相互连接，相互依赖，使得一个单一的行为似乎不太可能在没有其他对象的支持下工作，进而使整个系统进行任何较大的改动和扩展都会变得十分困难，此时我们就可以考虑使用中介者模式。

## 6.2 定义与模式描述

中介者模式：用一个中介对象来封装一系列的对象交互，中介者是个对象，不需要显式的相互引用，从而使其结构松散，而且可以独立地改变他们之间的交互。

## 6.3 角色组成与参与者

#### 抽象中介者(Mediator)

终结者类的基类或接口类的定义一个接口用于各同事对象通信。

#### 具体中介者(ConcreteMediator)

继承自抽象终结者，具体中介者通过协调各同事对象实现协作行为，他一般会了解并维护其他的各个同事。

#### 抽象同事类(Colleague)

抽象同事类作为所有同事类的鸡肋或接口类，他知道中介者对象的存在。

#### 具体同事类(ConcreteColleague)

继承自抽象同事类，每个具体同事类都完成一个特定的行为或功能，当需要和其他同事配合工作时，通过中介者通信和调度。

## 6.4 UML图与时序图

### 6.4.1 UML图

![[计算机理论基础/设计模式/attachments/Pic_014.png]]

### 6.4.2 时序图

![[计算机理论基础/设计模式/attachments/Pic_015.png]]

## 6.5 优缺点

#### 优点

中介者模式最大的优点是简化了对象之间的交互，减少个同事之间的耦合性。

此外中介者模式可以简化各同事类的设计和实现，减少子类的生成。

#### 缺点

同事之间的交互细节全部集中在Mediator类中，可能导致具体中介者类非常复杂，使得系统难以维护。

# 7. 备忘录(Memento)模式

## 7.1 背景与动机

在日常开发当中，我们经常会遇到这样的情况：我们需要将某对象恢复到他原来的某个状态。但是根据开闭原则对象，通常将这些状态信息封装到了对象内部，这也就意味着我们不可能在外部拿到对象的状态。而暴露对象的内部状态，又会违反开闭原则，此就可以考虑使用备忘录模式。常见的可以使用备忘录模式的两个常应用场景有：在某编辑器中进行编辑操作时会自动存档，并且支持CTRL Z还原到上一状态。另外一个应用场景则是在游戏开发中，我们经常会遇到对远端对象位置的模拟，当我们发现位置模拟出现较大偏差时，可能需要恢复到之前某一状态。这两种情况都可以使用备忘录模式来记录之前状态，以供外部逻辑在适当的时机还原到该状态。

## 7.2 定义与模式描述

备忘录(Memento)模式：在不破坏封装性的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以将该对象恢复到原先保存的这个状态。

## 7.3 角色组成与参与者

#### 原发器/发起人(Originator)

原发器/发起人(Originator)负责创建一个备忘录，用于记录当前时刻它的内部状态，并可以使用备忘录恢复这些状态。原发器/发起人(Originator)可以根据需求决定备忘录(Memento)存储Originator中的哪些内部状态。简单来说，原发器/发起人就是需要被存储状态的这个对象类。

#### 备忘录(Memento)

负责存储原发器/发起人(Originator)对象的内部状态，并可防止原发性/发起人(Originator)以外的其他对象访问备忘录。实际上备忘录有两个接口，管理者(Caretaker)只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。此外相反的，原发器/发起人(Originator)能够看到一个宽接口，允许他访问返回到先前状态所需的所有数据。

#### 管理者(Caretaker)

管理者负责保存备忘录信息，但管理者不能对备忘录的内容进行操作或检查。

## 7.4 UML图与时序图

### 7.4.1 UML图

![[计算机理论基础/设计模式/attachments/Pic_016.png]]

### 7.4.2 时序图

![[计算机理论基础/设计模式/attachments/Pic_017.png]]

## 7.5 优缺点

#### 优点

为用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回溯到某个历史状态。

实现了信息的封装，使得用户不需要关心状态的保存细节。

#### 缺点

如果原发器/发起人(Originator)类的成员过多，势必会占用大量的资源，而且每一次保存都会消耗一定的额外内存。

# 8. 观察者(Observer)模式

## 8.1 背景与动机

观察者模式的动机是要建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应，在此发生改变的对象称之为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更容易扩展，这就是观察者模式的动机。

## 8.2 定义与模式描述

观察者(Obseever)模式：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生变化时，其相关依赖对象皆得到通知并被自动更新。

## 8.3 角色组成与参与者

#### 目标(Subject)

目标类也就是观察目标的基类，他知道观察者的存在，可以有任意多个的观察者观察同一目标。目标类提供注册和删除观察者对象的接口。

#### 具体目标(ConcreteSubject)

继承自目标类，将有关状态存入各具体观察者对象中。当他的状态发生变化时，向各个观察者发出通知。

#### 观察者(Observer)

那些在目标发生改变时，需要获得通知的对象定义的一个更新接口类。

#### 具体观察者(ConcreteObserver)

维护一个指向具体目标类对象的引用存储有关状态，这些状态应该与目标状态保持一致，侦听目标状态的变更，当目标状态发生变更时，修改更新本地维护的相关状态。

## 8.4 UML图与时序图

### 8.4.1 UML图

![[计算机理论基础/设计模式/attachments/Pic_018.png]]

### 8.4.2 时序图

![[计算机理论基础/设计模式/attachments/Pic_019.png]]

## 8.5 优缺点

#### 优点

观察者模式可以实现表现层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表现层，作为具体观察者角色。

观察者模式在观察目标和观察者之间建立了一个抽象的耦合。

观察者模式支持广播通信。

观察者模式符合开闭原则的要求。

#### 缺点

如果一个观察目标对象有很多直接或间接观察者的话，将所有的观察者都通知到会花费很多时间，且发生问题和异常时较难排错。

由于观察者之间并不知道彼此的存在，如果观察者之间有相互循环依赖或其他关联时，可能导致逻辑执行错误，甚至发生系统崩溃。

# 9. 状态(State)模式

## 9.1 动机与背景

在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态。这样的对象叫做有状态的对象，这样的对象状态是从事先定义好的一系列之中取出的，当一个这样的对象与外部事件产生互动时，其内部的状态就会发生改变，从而使得系统的行为也随之变化，此时我们就可以考虑使用状态模式。

## 9.2 定义与模式描述

状态(State)模式允许，一个对象在其内部状态改变时改变它的行为对象看起来，似乎是改变了他的类。

## 9.3 角色组成与参与者

#### 状态(State)

状态类定义一个接口以封装与Context环境的一个特定状态相关的行为。

#### 具体状态(ConcreteState)

状态(State)的派生类，每一个子类实现一个与Context环境中特定状态相关的行为。

#### 环境类(Context)

定义用户感兴趣的接口，维护一个State子类的实例，这个实例定义当前状态。

## 9.4 UML图与时序图

### 9.4.1 UML图

![[计算机理论基础/设计模式/attachments/Pic_020.png]]

### 9.4.2 时序图

![[计算机理论基础/设计模式/attachments/Pic_021.png]]
![[计算机理论基础/设计模式/attachments/Pic_022.png]]

## 9.5 优缺点

#### 优点

状态模式枚举可能的状态，在没举状态之前需要确定状态，种类它相当于封装了状态转换的规则。

他将所有与某个状态有关的行为放到一个类中，并且可以方便的增加新的状态，只要改变对象状态，即可改变对象的行为。

允许状态转换逻辑与状态，对象合为一体，避免了一个巨大的if else语句块。

#### 缺点

由于每一种行为都是一个具体状态类，因此状态模式必然会增加系统类和对象的个数。

状态模式的结构和实现相对复杂，如果使用不大可能导致程序结构和代码的混乱。

状态模式对开闭原则的支持不太友好，当新增一个新的状态类时，我们不得不去修改负责状态转换的源代码。

# 10. 策略(Strategy)模式

## 10.1 背景与动机

完成一项任务往往可以有很多不同的方式，每一种方式成为一个策略，我们可以根据环境或者条件的不同，选择不同的策略来完成这个任务。在程序开发过程中，我们经常接触到算法，其实每一种算法就是一个解决问题的策略。当我们为用户提供一个系统，而系统这个而这个系统中又有许多不同的算法策略时，简单的把这些策略类交给用户直接使用，可能将会是一个灾难。用户直接包含和使用不同的策略类，可能会使得用户的程序庞大而又难以维护。如果存在大量可供选择的算法时，问题将变得更为严重，此时用户将不得不去考虑使用算法的条件以及算法之间的切换的问题。为了解决这些问题，我们可以使用策略模式。

## 10.2 定义与模式描述

策略(Strategy)模式：定义一系列算法将每一个算法封装起来，并让他们可以相互替换。策略模式使得算法独立于使用它的客户而变化。

## 10.3 角色组成与参与者

#### 抽象策略(Strategy)类

定义所有支持的算法的公共接口，环境类Context使用这个接口来调用某具体定义的算法。

#### 具体策略(ConcreteStrategy)类

继承字抽象策略类接口实现某一具体算法。

#### 3环境(Context)类

环境类维护一个具体策略类的引用，并调用该策略类实现具体算法。

## 10.4 UML图与时序图

#### 4.1 UML图

![[计算机理论基础/设计模式/attachments/Pic_023.png]]

#### 4.2 时序图

![[计算机理论基础/设计模式/attachments/Pic_024.png]]

## 10.5 优缺点

#### 优点

策略模式符合开闭原则用户可以在不修改原有系统的基础上选择算法或行为也可以灵活地增加新的算法或行为。

策略模式提供了管理相关的算法簇的办法。

使用策略模式也可以避免使用多重条件转移语句。

#### 缺点

用户端必须知道所有的策略类并自行决定使用哪一个策略类。

策略模式将造成产生很多的具体策略类，可以通过使用享元模式在一定程度上减少对象的数量。

# 11. 模板方法(TemplateMethod)模式

## 11.1 背景与动机

在定义和新增派生类时，我们经常会遇到这种尴尬的情景：派生类与父类在某一方法上只有些许细微的不同，但我们不得不去重写整个流程并对其中一小部分进行修改。一个非常经典的例子就是泡茶和咖啡。泡咖啡的步骤可以分为：把水烧开，将咖啡放入咖啡壶，加热水冲泡咖啡，将咖啡倒入杯子中四个步骤。泡荼的步骤也可以分为：把水烧开，将茶放入茶壶，加水冲泡茶，将荼倒入杯子中四个步骤。他们的主体结构或流程是一致的，只有细微的差别，此时就适合使用模板方法模式。

## 11.2 定义与模式描述

模板方法(TemplateMethod)模式：定义一个操作中的算法骨架，而将一些步骤延迟到了子类中。模板方法使得子类可以不改变一个算法的结构和主体，既可以重定义该算法的某些特定步骤和细节。

## 11.3 角色组成与参与者

#### 抽象类(AbstractClass)

定义抽象的原语操作具体的子类将重定义他们已实现一个算法的各个步骤。也可以理解为实现一个模板方法定义算法的骨架，该模板方法不仅调用原操作也可以调用定义，在抽象类或其他对象中的操作。

#### 具体(ConcreteClass)类

继承自抽象类，实现源于操作细节已完成算法中与特定子类相关的步骤。

## 11.4 UML图

![[计算机理论基础/设计模式/attachments/Pic_025.png]]

## 11.5 优缺点

#### 优点

模板方法模式完美的实现了，封装不变部分，扩展可变部分。

模板方法模式提取公共代码，便于维护行为，由父类控制，子类实现具体细节。

#### 缺点

每一个不同的实践都需要一个子类来完成，导致类的数量激增，使得系统维护更加复杂。

# 12. 访问者(Visitor)模式

## 12.1 背景与动机

访问者(Visitor)模式的主要目的是将数据结构与数据操作进行分离。试想这样一个应用场景：我们定义了一个商品属性类，该类维护了商品所需要的各种属性(eg: 价格、类别、生产日期等)。我们的系统是为超市提供一个商品管理系统，但是随着超市的运营系统需要不断的扩展和迭代一些对商品的操作接口。例如：按照不同的策略查询商品、添加、删除商品，修改商品价格、打折策略等。如果所有逻辑都写在商品类中，那么每次修收都需要去修改商品类，此时我们就可以使用访问者模式，将数据与操作分离，通过扩展操作的方式，避免修改原始商品类。

## 12.2 定义与模式描述

访问者模式表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。

## 12.3 角色组成与参与者

#### 访问者(Visitor)

为对象结构中的每个元素类声明一个访问操作接口。使得访问者派生类可以通过相应的接口访问修改对象结构中某一具体元素。

#### 具体访问者(ConcreteVisitor)

是访问者类的派生类，实现访问者类中对对象结构中每个元素的具体操作，确定访问者访问一个元素时应该做什么？对应于上文商品示例中每次新增的操作。

#### 元素(Element)

元素类可以看作是一个定义了接收访问接口的元素操作基类。他定义了接收访问者访问的接口Accept操作，并以访问者为参数。

#### 具体元素(ConcreteElement)

元素类的派生类具体实现accept操作该操作，以一个访问者为参数。具体元素相当于上文中商品示例中每个商品的具体属性。

#### 对象结构(ObjectStructure)

对象结构是对所有元素的管理，它可以是一个组合或一个集合，可以提供一个高层的接口，以允许访问者访问它的元素。相当于上文商品示例中的商品类。

## 12.4 UML图与时序图

#### 12.4 UML图

![[计算机理论基础/设计模式/attachments/Pic_026.png]]

#### 4.2 时序图

![[计算机理论基础/设计模式/attachments/Pic_027.png]]

## 5. 优缺点

#### 优点

符合单一职责原则。

具有优秀的扩展性和灵活性。

#### 缺点

具体元素对访问者公布细节违反了封闭式原则。

具体元素变更比较困难。

违反了依赖倒置原则，依赖了具体类，并没有依赖抽象类或接口类。