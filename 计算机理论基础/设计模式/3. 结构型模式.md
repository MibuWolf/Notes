---
tags:
  - DesignPatterns
---

# 1. 概述

在上一章中我们讨论了创建对象时使用的创建型模式，本章将要讨论的结构型模式则涉及如何组合类和对象以获得更大的结构。结构性模式可以分为类结构型模式和对象结构性模式:

类结构型模式关心类的组合，由多个类可以组成一个更大的系统，在类结构模式中一般只存在继承关系和实现关系。

对象结构性模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。

常见的结构型模式有适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式和代理模式，在本章中，我们将对其分别介绍并讨论其相关性和区别。

# 2. 适配器(Adapter)模式

## 2.1 背景与动机

在实际开发过程当中经常会遇到这样的情况: 希望将一个现有的类纳入到当前的接口体系当中。举个例子来说，在UE引擎的GAS系统中定义了Task接口类，当前需要一个属性变更的Task。但由于属性类Attribute类的又并非继承自Task，此时就需要一种方式将Attribute纳入到Task体系中，形成我们所需要的Attribute Task。这就是适配器模式的应用环境和使用背景。

## 2.2 定义与模式描述

适配器模式的作用就是将一个接口转化为用户所希望的另一个接口，使得接口不兼容的那些类可以一起工作。实现这一目标有两种方式：通过继承实现的类适配器和通过组合实现的对象适配器，我们将在下文的UML图中给出两种适配器的实现方式。

## 2.3 角色组成与参与者

无论是类适配器还是对象适配器，都由以下成员组成：

#### Client：

用户类，最终使用适配器的类。

#### Target：

目标抽象类，最终被Client使用的类。

#### Adapter(适配器)：

我们当前定义使用的接口基类对应上文GAS示例中的Task类。

#### Adaptee(适配者)：

已经存在的一个类，也就是我们需要适配到接口的类，对应于上文GAS示例中的Attribute类。

## 2.4 UML图与时序图

#### 对象适配器

![[计算机理论基础/设计模式/attachments/Pic_028.png]]

#### 类适配器

![[计算机理论基础/设计模式/attachments/Pic_029.png]]

#### 时序图

![[计算机理论基础/设计模式/attachments/Pic_030.png]]

## 5. 优缺点

#### 优点

将目标类和适配者类结偶，通过引入一个适配器类，复用现有的适配者类而无需修改原有代码。

灵活性和扩可扩展性也很好，仅通过新增适配器类就可以简单的复用现有的功能类，而且完全符合开闭原则。

增加了类的复用，性通过适配器类就可以复用现有的功能类，将现有功能类加入到新的接口体系当中。

#### 缺点

对于类配过器Java和C#当中不支持多重继承，一次最多只能适配一个适配者类，而且适配器类(Adapter)只能为抽象类不能为具体类，因此具有一定的局限性。

对于对象适配器如果一定要置换掉适配者类中的一个或多个方法，就只能先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类，当做真正的适配者进行适配，实现过程较为复杂。

# 3. 桥接(Bridge)模式

## 3.1 背景与动机

在开发当中我们经常遇到这样的系统，它有两个变化维度。例如我们设计一个窗口类，该类既可以在功能层面进行扩展: 派生出窗口类图片窗口类弹窗窗口类的，也可以在系统层级进行扩展，例如支持Windows系统下的窗口，支持Linux下面的窗口的。对于这种有两个变化维度的系统，就适合使用桥接模式，将两个维度分离，使他们可以独立的变化。

## 3.2 定义与模式描述

桥接模式将抽象部分与它的实现部分分离，使他们都可以独立的变化，桥接模式是一种对象结构型模式又被称为接口模式。

## 3.3 角色组成与参与者

桥接模式一般由以下几个角色组成:

#### Abstraction(抽象类):

定义该系统的一个抽象类的接口，对应上述窗口示例中的IWindows类。

#### RefinedAbstruction(扩展抽象类):

是派生自抽象类的一个具体业务类，对应上述窗口示例中的弹窗窗口类图片，窗口类等等内容。

#### Implementor(实现类接口):

该模式本质是将抽象和实现分离，因此需要一个实现类的接口来作为不同时限的基类，对应上述窗口事例中，在不同系统中实现的接口类。

#### ConcreteImplementoer(具体实现类):

继承自实现类接口对应上述窗口势力中的Windows平台的时限或者Linux平台的实现。

## 3.4 UML图与时序图

#### UML图

![[计算机理论基础/设计模式/attachments/Pic_031.png]]

#### 时序图

![[计算机理论基础/设计模式/attachments/Pic_032.png]]

## 5. 优缺点

#### 优点

接口与实现部分分离: 接口与实现部分分离，不仅提供了更大的灵活性，而且有利于分层，可以分别在不同的层级上，对接口和实现部分分别进行扩展和扩充。

由于实线与接口的分离，可以对客户透明隐藏，实现细节，仅为客户提供接口部分。

#### 缺点

引入调节模式会增加系统理解的复杂度和难度，由于接口和实现的聚合关系建立在抽象层，要求开发者对抽象进行设计和编程。

桥接模式支持两个维度的变化，但在进行设计时要求正确识别出系统的两个独立变化的维度，因此使用该模式具有一定的局限性。

# 4. 组合(Composite)模式

## 4.1 背景与动机

在应用程序开发，尤其是游戏开发当中，我们经常会遇到这种情况，我们需要将多个简单的功能通过不同形式的拼装组合形成一个新的效果，例如：在游戏当中我们可以通过对移动，动作播放，行为控制，模型渲染等功能的不同组合，形成游戏中的不同对象。此时就比较适合使用组合模式。

再举一个例子，假设我们要制作一个UML图绘制工具，在此工具中我们既可以绘制简单的直线，文字，长方形，也可以绘制一个结点，而这个结点则是由长方形直线和文字拼装组合而成。

## 4.2 定义与描述

组合模式有时又被称为整体-部分模式，它是一种将对象组合成树状的层次结构的模式，用来表示整体与部分的关系，使用户对单个对象和组合对象具有一致的访问性。

## 4.3 角色组成与参与者

组合模式一般由以下几个参与者组成：

#### Component(抽象组件):

Component类为组合中的对象提供接口，一般情况下所有类都继承自该接口类。

#### Leaf(叶子结点):

组合模式中的叶子节点一般用来实现一个具体的行为，例如上文中绘制UML图工具示例中的直线，文字类就是一个叶子节点(完成和实现一个具体的功能，例如对文字或直线的绘制)，叶子节点执行和实现一个具体的功能，一般没有派生类或子节点。

#### Composite(复合节点):

符合节点的作用是组合和存储其他叶子节点，并在Component接口中实现与子部件有关的操作。

## 4.4 UML图

![[计算机理论基础/设计模式/attachments/Pic_033.png]]

## 4.5 优缺点

#### 优点

由于整个组合模式采用的树形结构，因此使得定义层级十分清晰。

用户可以一致性的使用叶子节点和组合节点，事实上用户根本不需要关心每一个类是叶子节点还是组合节点降低了用户的理解成本，增加了功能复用性。

整个组合模式比较易于扩展，当新增一个功能时，既可以通过新增叶子节点的方式扩展，也可以通过对现有叶子节点的组合进行扩展。

#### 缺点

缺点则是使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大的挑战性，而且不是所有的方法都与叶子节点对象和子类有关联。

# 5. 装饰 (Decorator)模式

## 5.1 背景与动机

在开发过程当中，我们经常遇到这种情况，在运行时我们希望动态地给一个对象添加更多的能力或效果。例如我们希望根据用户的操作给一张图片动态的添加边框扭曲，模糊等各种不同的效果，此时我们就应该考虑装饰模式。

## 5.2 定义与描述

装饰(Decorator)模式可以动态地给一个对象增加一些额外的职责，就增加对象功能而言，装饰模式比生成子类的实现更为灵活。

## 5.3 角色组成与参与者

#### Component(抽象组件)：

一个抽象的组建对象，可以给这些对象动态的添加新的职责。

#### ConcreteComponent(具体构件)：

继承自抽象组件类的一个对象，可以给这个对象添加一些额外的职责。

#### Decorator(抽象装饰类)：

一个继承自Component的抽象装饰类，它的接口与Component接口保持一致，用于定义修饰ConcreteComponent的装饰基类.

#### ConcreteDecorator(具体装饰类)：

继承自抽象装饰类具有特定装饰功能的具体装饰的。

## 5.4 UML图与时序图

#### UML图

![[计算机理论基础/设计模式/attachments/Pic_034.png]]

![[计算机理论基础/设计模式/attachments/Pic_035.png]]

#### 时序图

![[计算机理论基础/设计模式/attachments/Pic_036.png]]

## 5.5 优缺点

#### 优点

装饰模式和继承关系的目的都是要扩展对象的功能，但装饰模式可以提供比继承更为灵活的方式，即在运行时可以动态扩展对象功能。

通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多种不同的行为组合，可以使用多个具体的装饰类来装饰同一对象，使得该对象的功能变得更为强大。

装饰类对象和被装饰的具体组件类对象可以分别独立的变化，在使用时对其进行组合，从而达到无需修改代码运行时实现多种表现的结果，符合开闭原则。

#### 缺点

使用装饰模式对对对目标对象进行描述时，很容易产生多个小的装饰类，这些小的装饰类对象将增加系统维护的复杂度和维护成本。

装饰模式比继承的方式更为灵活，这也就意味着使用装饰模式比使用继承更容易出错，当对一个对象进行多次修复时修饰时，也就意味着需要逐级排错较为繁琐。

# 6. 外观(Facade)模式

## 6.1 背景与动机

很多时候，我们的系统是由多个子系统组成，而每一个子系统拥有自己庞大而复杂的结构和调用关系。但对于整个系统而言，该子系统的内部实现，细节并非外部程序所关心，此时就适合使用外观模式将此系统通过外观对象对外提供接口。

## 6.2 定义与描述

外观(Facade)模式: 外部与一个子系统的通信，必须通过一个统一的外观对象进行，为此系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，使用这个接口使得这一子系统更加容易使用。

## 6.3 角色组成与参与者

#### Facade(外观)

外观类对象一般是子系统对外的出口，他知道哪些子系统类负责处理请求，并将客户的请求代理给适当子系统中的对象。

#### SubSystemClasses(子系统类)

实现子系统的内部类。

## 6.4 结构图UML图及时序图

#### 结构图

![[计算机理论基础/设计模式/attachments/Pic_037.png]]

#### UML图

![[计算机理论基础/设计模式/attachments/Pic_038.png]]
![[计算机理论基础/设计模式/attachments/Pic_039.png]]

#### 时序图

![[计算机理论基础/设计模式/attachments/Pic_040.png]]

## 6.5 优缺点

#### 优点

对用户侧屏蔽了此系统内部的细节减少了用户的使用成本。

实现了子系统与用户之间的松散耦合关系，这使得子系统内部的变化不会影响到调用它的客户类，只需要调整外观类即可。

外观模式只是提供了一个用户访问子系统的统一入口，这并不意味着用户不可以直接调用子系统类。

#### 缺点

不能很好的限制用户使用此系统内，如果对用户访问子系统内做太多的限制和规则，那么就减少了用户使用的可变性和灵活性。

在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端源代码，这违背了开闭原则。

# 7. 享元(Flyweight)模式

## 7.1 背景与动机

面向对象技术可以很好的解决一些灵活性和扩展性的问题，但在某些情况下需要在系统中增加类和对象的个数，但当对象数量太多时，又会导致运行代价过高，带来性能下降等问题。例如，我们在编写一个文本编辑器程序时，如果将文字、每一行、每一页分别抽象成文字类、行类、页类。那么毫无疑问，在运行时我们的文本编辑器当中将会有大量的文字类对象，对于海量的文字类对象操作时必然会有内存或性能等问题，而此时就适合使用享元模式。

## 7.2 定义与描述

享元模式是运用共享技术，有效的支持大量细颗粒度对象的复用，系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用，对于就模式要求能够共享的对象必须是细颗粒度对象，因此它又被称为轻量级模式，它是一种对象结构形模式。

## 7.3 角色组成与参与者

#### Flyweight(抽象享元类)：

抽象享元类也就是大量细颗粒度类对象类的基类或者接口类。通过这个接口类享元可以接受并作用于外部状态。对应于上文文本编辑器示例中的文字类、行类、页类的基类。

#### ConcreteFlyweight(具体享元类):

继承自抽象享元类的，用于共享的具体享元类。虽然具体想员类对象是用于多实力共享的，但这不意味着其内部的所有内容都是共享的。在具体享元类中可以共享的相同内容被称为内部状态，而那些需要外部环境来设置的，不能共享的内容称为外部状态。对应于上文文本编辑器示例中的文字类。

#### FlyweightFactory(享元工厂类)

在享元模式中通常也会使用工厂类，需要创建一个享元工厂来维护一个享无池用于存储具有相同内部状态的享元对象。

#### UnsharedConcreteFlyweight(非共享具体享元类)

并非所有的抽象享元类的派生类都需要被共享使用。虽然抽象享元类接口使共享成为可能，但它并不意味着强制共享。正如上文文本编辑器示例中的行类、页类。

## 7.4 结构图UML图及时序图

#### 结构图

![[计算机理论基础/设计模式/attachments/Pic_041.png]]

#### UML图

![[计算机理论基础/设计模式/attachments/Pic_042.png]]

#### 时序图

![[计算机理论基础/设计模式/attachments/Pic_043.png]]

## 7.5 优缺点

#### 优点

享元模式的最大优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象的内存中只要保存一份。

享元模式的外部状态相对独立，而且不会影响内部状态，从而使得享元对象可以在不同环境中被共享。

#### 缺点

享元模式使得被共享的对象设什比较复杂，需要分离出内部状态和外部状态。

为了使对象可以共享享元模式，需要将享元对象的状态外部化，增加了外部使用者的设计复杂度。

**_注_**： **_这里需要对享元模式中具体享元类的内部状态和外部状态做一个特别说明。回到最初的文本编辑器示例，我们知道文字类是一个具体的享元类。而我们需要共享的内部状态是文字本身：eg:_** A B **_C或某个特定汉字的具体字符，但在文本编辑器中对于该文字的额外描述，例如某个字母A的字体字号，粗度等信息则属于外部状态。外部状态需要用户或其他类单独维护，就上述文本编辑器示例而言，我们可以将内部状态具体的字符用内存池等形式进行共享，而文字的顺序，字符字号等外部对象信息，则可以存在行类对象信息中。_**

# 8. 代理(Proxy)模式

## 8.1 背景与动机

在某些情况下，用户不想或者不能直接引用一个对象，此时可以通过一个称为代理的第三者来实现间接引用，代理对象可以在用户端和目标对象之间起到中介作用，并且可以通过代理对象去掉用户不能看到的内容和服务，或者添加用户所需要的额外服务。这就是代理模式的使用背景和动机。

例如：一个文本编辑器，其中有一可编辑控件对象为图片。为了增加编辑器打开文件时的效率，我们并不希望打开某一文件时，立即加载文件中所有的图片信息，而是当我们翻到存有文图片信息的页面时，才真正执行这一图片的加载工作。此时对于图片控件的加载，就可以使用代理模式进行控制和管理。

## 8.2 定义与描述

代理模式就是给某一对象提供一个代理，并由代理对象控制对原对象的引用，它是一种对象结构型模式。

## 8.3 角色组成与参与者

#### Subject(抽象主题角色)

定义真实角色类和代理角色类的共用接口，这样就在任意使用真实角色类的地方都可以使用代理角色类。对应上文文本编辑器中所有控件类的基类。

#### RealSubject(真实主题角色)

隐藏在代理对象之后的真实对象类。也就是上文文本编辑器示例中的图片类。

#### Proxy(代理主题角色)

保存真实主题角色类对象，并提供一个与真实类对象相同的接口，这样就可以在代理类中实现一些额外的处理。对应于上文文本编辑器事例中的代理图片类。常见代理类型有RemoteProxy，负责对远端服务器端对象进行代理处理。

## 8.4 结构图UML图及时序图

#### 结构图

![[计算机理论基础/设计模式/attachments/Pic_044.png]]

#### UML图

![[计算机理论基础/设计模式/attachments/Pic_045.png]]
![[计算机理论基础/设计模式/attachments/Pic_046.png]]

#### 时序图

![[计算机理论基础/设计模式/attachments/Pic_047.png]]

## 8.5 优缺点

#### 优点

代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合性。

RemoteProxy可以使得客户端可以无感的访问远程机器上的对象，降低了设计和实现的复杂度。

通过代理可以限制用户使用和访问真实对象的权限。

#### 缺点

实现代理模式需要额外的工作，有些代理模式的实现可能非常复杂，增加了设计的复杂性。

由于用户并不直接调用真实对象而是通过代理对象进行操作，因此在某些情况下代理模式可能造成请求处理的延迟或缓慢。

# 9. 几种模式的相似性与区别

你可能也注意到了结构型模式之间的相似性，尤其是他们的参与者与协作者之间的相似性，这是因为结构型模式本身就是描述类与对象的关系。而类与对象的关系无非是继承与组合，这些相似性掩盖了这些模式的不同，因此我们本节将讨论这些模式的相似性以及其各自的细微不同点和倾向。

## 9.1 适配器(Adapter)、桥接(Bridge)、装饰(Decorator)、外观(Facade)、代理(Proxy)

### 9.1.1 相同点

回顾一下本章几种结构型设计模式的UML图，抛开UML图中类名的不同，我们发现适配器模式、桥接模式、装饰模式、外观模式、代理模式都有一个共同点：

在某种程度上，他们都将用户的使用与真正生效的类进行了隔离，他们都给另一个对象提供了一定程度的间接性，因而有利于系统的灵活性，将用户的直接调用与实现进行了某种程度上的分离。

### 9.1.2 不同点

虽然这几种模式都在一定程度上起到了使用户间接调用对象的功能。但他们的设计目的不同、使用的时机与应用场景也是不同的。

#### 设计目的

适配器(Adapter)模式的主要目的是：使得原本由于接口不兼容而不能一起工作的类可以一起工作。

桥接(Bridge)模式的主要目的是：分离接口与实现可以让接口以实和实现各自独立不同的变化。

装饰模式(Decorator)的主要目的是：给对象在运行时动态的添加一些额外的职责或功能。

外观(Facade)模式的主要目的是：对用户屏蔽子系统的复杂的内部实现，为子系统提供一个简单的高层接口供用户使用。

代理模式(Proxy)的主要目的是：当用户不适合直接引用目标对象时，代理对象可以在目标和用户之间起到中介的作用。

**_注：实际上我们很容易把代理模式和装饰模式混淆，从UML图上来看，两者也非常的接近，那我们要怎么样区分两种模式呢？这里举一个例子，假设目标类是小朋友吃饭，装饰模式相当于是要告诉小朋友吃饭前要洗手，吃完饭要收拾碗筷，而代理模式则是借父母之手喂小朋友吃饭。当你搞不清楚，应该用代理模式还是装饰模式的时候，想想小朋友吃饭的这个例子吧。_**

#### 使用时机与应用场景

适配器(Adapter)模式：适配器模式通常会被用在软件开发的中后期，随着功能开发的进行当你发现两个不兼容的类必须同时工作时，就有必要考虑使用适配器模式，其目的一般是为了避免代码重复。

桥接(Bridge)模式：调节模式通常在设计初期或编码初期使用，桥接模式的使用者必须事先知道一个抽象有多个实现部分，并且抽象和实现两者是独立演化的。

装饰(Decorator)模式：装饰模式既有可能在系统设计时预先规划，也有可能是在后期随着需求的扩展而动态添加。其目的也非常明确，在运行时动态为目标内添加额外的功能或修饰。

外观(Facade)模式：大多数时候外观模式发生在软件开发的中后期，它与其他结构型模式的不同点在于它为用户屏蔽的不是类对象，而是一个子系统。虽然在作用或功能上它与适配器模式很类似，但其根本不同点在于：适配器模式针对的是类或接口，而外观模式针对的是一个子系统。

代理(Proxy)模式：代理模式的使用既可能发生在系统设计的前期，也可能发生在后期迭代优化时。其主要的应用场景和环境是用户不能或者不方便直接持有目标类对象时使用。

## 9.2 组合(Composite)模式、装饰(Decorator)模式、代理(Proxy)模式

### 9.2.1 相同点

重新回顾一下组合模式，装饰模式和代理模式三者的UML图，我们会发现三种模式具有类似的结构图，这说明他们都基于递归组合来组织可变数目的对象。

### 9.2.2 不同点

组合模式的目的在于构造类是多个相关的对象，能够以统一的方式来处理，而多个对象可以被当作一个对象来处理，它的重点在于表示。

装饰模式旨在使你不需要生成子类即可给对象添加额外职责，这样就避免了静态实现所所有功能组合，从而导致的子类急剧膨胀的问题。

代理模式虽然与装饰模式类似为构建一个对象并为用户提供了一致性的接口。但代理模式不能动态地添加或分离某些额外的装饰特性或功能，其目的是直接访问一个用户不方便或不适合直接访问的对象。